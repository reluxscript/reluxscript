# Writer Hooks Implementation Plan

**Date:** 2025-01-23
**Status:** Design Document
**Issue:** Writers parse hooks but don't generate them in output

---

## Problem Statement

The ReluxScript specification (Section 19, line 2267) shows that `writer` blocks should generate Babel plugins with a `post()` hook to finalize output:

```javascript
module.exports = function() {
  const builder = new CodeBuilder();
  return {
    visitor: { /* ... */ },
    post(file) {
       file.metadata.output = builder.toString();
    }
  }
}
```

However, the current implementation generates writers as **standalone classes**, not Babel plugins:

```javascript
class TsxToCSharp {
  constructor() {
    this._output = [];
  }
  // ... methods ...
}
module.exports = TsxToCSharp;
```

**The Gap:**
- Parser accepts `fn pre()` and `fn exit()` in writer blocks
- Codegen silently ignores them (only processes `PluginItem::Function`)
- No way to finalize output or access original source

---

## Design Decisions

### 1. Writer Purpose & Architecture

Writers serve a different purpose than plugins:

| Aspect | Plugin | Writer |
|--------|--------|--------|
| **Purpose** | Transform AST | Generate output from AST |
| **Mutation** | `&mut Node` | `&Node` (read-only) |
| **Output** | Modified AST | Accumulated string |
| **State** | Plugin-level state | Builder instance |

### 2. Hook Semantics for Writers

Writers should support:

- **`pre(file)`**: Access to original source before traversal (same as plugins)
- **`exit(program, state)`**: Finalize and export accumulated output
- **No `post(file)`**: Spec shows `post()`, but `exit()` is more consistent with plugin API

**Rationale:** Use the same hook names (`pre`/`exit`) for consistency with plugins, but different semantics:
- Plugin `exit()`: Final AST transformations
- Writer `exit()`: Finalize and export generated output

---

## Implementation Plan

### Phase 1: Update Writer Code Generation (Babel)

**File:** `reluxscript/src/codegen/babel.rs`

**Current Code (lines 514-550):**
```rust
fn gen_writer(&mut self, writer: &WriterDecl) {
    // Generate writer as a class that builds output
    self.emit(&format!("class {} {{\n", writer.name));
    // ... constructor, methods ...
    self.emit(&format!("module.exports = {};\n", writer.name));
}
```

**New Code:**
```rust
fn gen_writer(&mut self, writer: &WriterDecl) {
    // Separate items by type
    let mut pre_hook: Option<&FnDecl> = None;
    let mut exit_hook: Option<&FnDecl> = None;
    let mut methods = Vec::new();
    let mut structs = Vec::new();

    for item in &writer.body {
        match item {
            PluginItem::PreHook(f) => pre_hook = Some(f),
            PluginItem::ExitHook(f) => exit_hook = Some(f),
            PluginItem::Function(f) => methods.push(f),
            PluginItem::Struct(s) => structs.push(s),
            _ => {}
        }
    }

    self.emit_line("// Generated by ReluxScript compiler");
    self.emit_line("// Do not edit manually");
    self.emit_line("");

    // Generate as Babel plugin that returns visitor + hooks
    self.emit(&format!("module.exports = function({{ types: t }}) {{\n"));
    self.indent += 1;

    // Generate CodeBuilder initialization
    self.emit_line("const builder = {");
    self.indent += 1;
    self.emit_line("_output: [],");
    self.emit_line("_indentLevel: 0,");
    self.emit_line("append(s) { this._output.push(s); },");
    self.emit_line("newline() { this._output.push('\\n'); },");
    self.emit_line("indent() { this._indentLevel++; },");
    self.emit_line("dedent() { this._indentLevel--; },");
    self.emit_line("toString() { return this._output.join(''); }");
    self.indent -= 1;
    self.emit_line("};");
    self.emit_line("");

    // Generate structs if any
    for struct_decl in structs {
        self.gen_struct_class(struct_decl);
        self.emit_line("");
    }

    // Generate helper functions
    for method in &methods {
        // Skip visitor methods (they go in the visitor object)
        if !method.name.starts_with("visit_") {
            self.gen_helper_function(method);
            self.emit_line("");
        }
    }

    // Generate pre hook if present
    if let Some(pre_fn) = pre_hook {
        self.emit_line("// Pre-hook");
        self.gen_helper_function(pre_fn);
        self.emit_line("");
    }

    // Generate exit hook if present
    if let Some(exit_fn) = exit_hook {
        self.emit_line("// Exit hook");
        self.gen_helper_function(exit_fn);
        self.emit_line("");
    }

    // Generate return object with visitor + hooks
    self.emit_line("return {");
    self.indent += 1;

    // Add pre() if present
    if pre_hook.is_some() {
        self.emit_line("pre(file) {");
        self.indent += 1;
        self.emit_line("pre(file);");
        self.indent -= 1;
        self.emit_line("},");
        self.emit_line("");
    }

    // Generate visitor object
    self.emit_line("visitor: {");
    self.indent += 1;

    // Add exit hook wrapper in Program visitor if present
    if exit_hook.is_some() {
        self.emit_line("Program: {");
        self.indent += 1;
        self.emit_line("exit(path, state) {");
        self.indent += 1;
        self.emit_line("exit(path.node, state, builder);");
        self.indent -= 1;
        self.emit_line("}");
        self.indent -= 1;
        self.emit_line("},");
        self.emit_line("");
    }

    // Generate visitor methods
    for method in methods {
        if method.name.starts_with("visit_") {
            // Convert visit_xxx to PascalCase node type
            let node_type = self.visitor_method_to_node_type(&method.name);
            self.emit_indent();
            self.emit(&format!("{}(path) {{\n", node_type));
            self.indent += 1;

            // Alias the node
            self.emit_line("const node = path.node;");

            // Generate method body with builder in scope
            self.gen_block(&method.body);

            self.indent -= 1;
            self.emit_indent();
            self.emit("},\n");
        }
    }

    self.indent -= 1;
    self.emit_line("}");  // Close visitor

    self.indent -= 1;
    self.emit_line("};");  // Close return object

    self.indent -= 1;
    self.emit_line("};");  // Close module.exports function
}
```

**Key Changes:**
1. Separate hooks from regular methods
2. Generate as `module.exports = function({ types: t })` instead of class
3. Create `builder` object with CodeBuilder methods in closure scope
4. Add `pre()` and `Program.exit()` hooks to returned object
5. Visitor methods can access `builder` via closure
6. Pass `builder` to exit hook as third parameter

---

### Phase 2: Update Writer Code Generation (SWC)

**File:** `reluxscript/src/codegen/swc.rs`

Writers in SWC should use the **read-only `Visit` trait** instead of `VisitMut`:

**Find the gen_writer method and update:**

```rust
fn gen_writer(&mut self, writer: &WriterDecl) {
    // Separate hooks from methods
    let mut exit_hook: Option<&FnDecl> = None;
    let mut methods = Vec::new();
    let mut structs = Vec::new();

    for item in &writer.body {
        match item {
            PluginItem::PreHook(_) => {
                // Pre-hook not supported in SWC (no source access)
                // Silently ignore or emit comment
            }
            PluginItem::ExitHook(f) => exit_hook = Some(f),
            PluginItem::Function(f) => methods.push(f),
            PluginItem::Struct(s) => structs.push(s),
            _ => {}
        }
    }

    self.emit_line("// Generated by ReluxScript compiler");
    self.emit_line("// Do not edit manually");
    self.emit_line("");

    // Generate use statements for read-only Visit
    self.emit_line("use swc_common::{Span, DUMMY_SP};");
    self.emit_line("use swc_ecma_ast::*;");
    self.emit_line("use swc_ecma_visit::{Visit, VisitWith};");  // Note: Visit, not VisitMut
    self.emit_line("");

    // Generate CodeBuilder struct
    self.emit_line("struct CodeBuilder {");
    self.indent += 1;
    self.emit_line("output: Vec<String>,");
    self.emit_line("indent_level: usize,");
    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");

    self.emit_line("impl CodeBuilder {");
    self.indent += 1;
    self.emit_line("fn new() -> Self {");
    self.indent += 1;
    self.emit_line("Self { output: Vec::new(), indent_level: 0 }");
    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");
    self.emit_line("fn append(&mut self, s: &str) { self.output.push(s.to_string()); }");
    self.emit_line("fn newline(&mut self) { self.output.push(\"\\n\".to_string()); }");
    self.emit_line("fn indent(&mut self) { self.indent_level += 1; }");
    self.emit_line("fn dedent(&mut self) { self.indent_level -= 1; }");
    self.emit_line("fn to_string(self) -> String { self.output.join(\"\") }");
    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");

    // Generate structs
    for struct_decl in structs {
        self.gen_struct(struct_decl);
        self.emit_line("");
    }

    // Generate writer struct
    self.emit(&format!("pub struct {} {{\n", writer.name));
    self.indent += 1;
    self.emit_line("builder: CodeBuilder,");
    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");

    // Generate impl block with constructor and helpers
    self.emit(&format!("impl {} {{\n", writer.name));
    self.indent += 1;

    self.emit_line("pub fn new() -> Self {");
    self.indent += 1;
    self.emit_line("Self { builder: CodeBuilder::new() }");
    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");

    // Generate finish() method (finalizer)
    if let Some(exit_fn) = exit_hook {
        // Use exit hook as finish method
        self.emit_line("pub fn finish(mut self) -> String {");
        self.indent += 1;
        self.gen_block(&exit_fn.body);
        self.emit_line("self.builder.to_string()");
        self.indent -= 1;
        self.emit_line("}");
    } else {
        // Default finish
        self.emit_line("pub fn finish(self) -> String {");
        self.indent += 1;
        self.emit_line("self.builder.to_string()");
        self.indent -= 1;
        self.emit_line("}");
    }
    self.emit_line("");

    // Generate helper methods (non-visitor)
    for method in &methods {
        if !method.name.starts_with("visit_") {
            self.gen_method(method);
            self.emit_line("");
        }
    }

    self.indent -= 1;
    self.emit_line("}");
    self.emit_line("");

    // Generate Visit trait impl (read-only)
    self.emit(&format!("impl Visit for {} {{\n", writer.name));
    self.indent += 1;

    // Generate visitor methods
    for method in methods {
        if method.name.starts_with("visit_") {
            // Convert to SWC visitor method name
            let swc_method = self.visitor_method_to_swc(&method.name);

            self.emit_indent();
            self.emit(&format!("fn {}(&mut self, n: &", swc_method));

            // Determine node type from method name
            let node_type = self.extract_node_type(&method.name);
            self.emit(&format!("{}) {{\n", node_type));

            self.indent += 1;
            self.gen_block(&method.body);
            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }
    }

    self.indent -= 1;
    self.emit_line("}");
}
```

**Key Changes:**
1. Import `Visit` trait instead of `VisitMut`
2. Generate `CodeBuilder` as a separate struct
3. Writer struct has `builder` field
4. `exit()` hook becomes `finish()` method that consumes self
5. Visitor methods take `&Node` not `&mut Node`
6. Pre-hook not supported (SWC doesn't provide original source)

---

### Phase 3: Update Examples and Tests

#### Example 1: TSX to C# Writer

**File:** `examples/tsx-to-csharp.rsc`

```reluxscript
writer TsxToCSharp {
    fn pre(file: &File) {
        babel! {
            // Save original source for error reporting
            builder._sourceFile = file.opts.filename;
        }
    }

    fn visit_jsx_element(node: &JSXElement) {
        let tag = node.opening_element.name;

        self.builder.append("new ");
        self.builder.append(tag);
        self.builder.append("({");

        // Process attributes...

        self.builder.append("})");
    }

    fn exit(program: &Program, state: &PluginState, builder: &CodeBuilder) {
        babel! {
            // Write output to file
            const fs = require('fs');
            const output = builder.toString();
            const outPath = state.file.opts.filename.replace('.tsx', '.cs');
            fs.writeFileSync(outPath, output);

            // Also save to metadata for testing
            state.file.metadata.csharpOutput = output;
        }
    }
}
```

**Generated Babel:**
```javascript
module.exports = function({ types: t }) {
  const builder = {
    _output: [],
    append(s) { this._output.push(s); },
    toString() { return this._output.join(''); }
  };

  function pre(file) {
    builder._sourceFile = file.opts.filename;
  }

  function exit(program, state, builder) {
    const fs = require('fs');
    const output = builder.toString();
    const outPath = state.file.opts.filename.replace('.tsx', '.cs');
    fs.writeFileSync(outPath, output);
    state.file.metadata.csharpOutput = output;
  }

  return {
    pre(file) {
      pre(file);
    },

    visitor: {
      Program: {
        exit(path, state) {
          exit(path.node, state, builder);
        }
      },

      JSXElement(path) {
        const node = path.node;
        const tag = node.openingElement.name;
        builder.append("new ");
        builder.append(tag);
        builder.append("({");
        builder.append("})");
      }
    }
  };
};
```

**Generated SWC:**
```rust
use swc_ecma_visit::{Visit, VisitWith};

struct CodeBuilder {
    output: Vec<String>,
}

impl CodeBuilder {
    fn new() -> Self { Self { output: Vec::new() } }
    fn append(&mut self, s: &str) { self.output.push(s.to_string()); }
    fn to_string(self) -> String { self.output.join("") }
}

pub struct TsxToCSharp {
    builder: CodeBuilder,
}

impl TsxToCSharp {
    pub fn new() -> Self {
        Self { builder: CodeBuilder::new() }
    }

    pub fn finish(mut self) -> String {
        // Babel-only code omitted (file I/O)
        self.builder.to_string()
    }
}

impl Visit for TsxToCSharp {
    fn visit_jsx_element(&mut self, n: &JSXElement) {
        let tag = &n.opening.name;
        self.builder.append("new ");
        self.builder.append(tag);
        self.builder.append("({");
        self.builder.append("})");
    }
}
```

#### Test Case

**File:** `tests/codegen/test_writer_hooks.rsc`

```reluxscript
writer TestWriterHooks {
    fn pre(file: &File) {
        babel! {
            builder._filename = file.opts.filename || "unknown";
        }
    }

    fn visit_identifier(node: &Identifier) {
        self.builder.append(node.name);
        self.builder.append(" ");
    }

    fn exit(program: &Program, state: &PluginState, builder: &CodeBuilder) {
        babel! {
            const output = builder.toString();
            state.file.metadata.collectedIdentifiers = output.trim();
        }
    }
}
```

**Expected Babel Output:** `tests/codegen/expected/test_writer_hooks.babel.js`

```javascript
module.exports = function({ types: t }) {
  const builder = {
    _output: [],
    append(s) { this._output.push(s); },
    toString() { return this._output.join(''); }
  };

  function pre(file) {
    builder._filename = file.opts.filename || "unknown";
  }

  function exit(program, state, builder) {
    const output = builder.toString();
    state.file.metadata.collectedIdentifiers = output.trim();
  }

  return {
    pre(file) {
      pre(file);
    },

    visitor: {
      Program: {
        exit(path, state) {
          exit(path.node, state, builder);
        }
      },

      Identifier(path) {
        const node = path.node;
        builder.append(node.name);
        builder.append(" ");
      }
    }
  };
};
```

---

### Phase 4: Update Specification

**File:** `docs/reluxscript-specification.md`

Update Section 19 (The Writer API) to clarify hook behavior:

```markdown
### 16.1 Writer Plugin Declaration

Writers support the same lifecycle hooks as plugins:

```reluxscript
writer TsxToCSharp {
    /// Pre-hook: Access original source before traversal
    fn pre(file: &File) {
        // Save metadata, access original code
    }

    /// Visitor methods (read-only)
    fn visit_jsx_element(node: &JSXElement) {
        self.builder.append("...");
    }

    /// Exit hook: Finalize and export generated output
    fn exit(program: &Program, state: &PluginState, builder: &CodeBuilder) {
        // Write output files, save to metadata
        babel! {
            const output = builder.toString();
            fs.writeFileSync(outPath, output);
        }
    }
}
```

**Compilation:**

```javascript
// Babel: Writer becomes plugin with hooks + visitor
module.exports = function({ types: t }) {
  const builder = { /* CodeBuilder methods */ };

  function pre(file) { /* ... */ }
  function exit(program, state, builder) { /* ... */ }

  return {
    pre(file) { pre(file); },
    visitor: {
      Program: {
        exit(path, state) { exit(path.node, state, builder); }
      },
      JSXElement(path) { /* ... */ }
    }
  };
};
```

```rust
// SWC: Writer uses Visit trait, exit becomes finish()
pub struct TsxToCSharp {
    builder: CodeBuilder,
}

impl TsxToCSharp {
    pub fn new() -> Self { /* ... */ }

    /// Finalize output (from exit hook)
    pub fn finish(self) -> String {
        self.builder.to_string()
    }
}

impl Visit for TsxToCSharp {
    fn visit_jsx_element(&mut self, n: &JSXElement) { /* ... */ }
}
```

**Hook Availability:**

| Hook | Babel | SWC |
|------|-------|-----|
| `pre()` | ✅ Available | ❌ Not supported (no source access) |
| `exit()` | ✅ Available as `Program.exit` | ✅ Becomes `finish()` method |

**Hook Parameters:**

- **Babel `pre(file)`**: Access to file metadata and original source
- **Babel `exit(program, state, builder)`**: Receives builder as third param
- **SWC `finish(self)`**: Consumes self, returns output string
```

---

### Phase 5: Semantic Validation

**File:** `reluxscript/src/semantic/resolver.rs`

Add validation that writers use hooks correctly:

```rust
fn validate_writer(&mut self, writer: &WriterDecl) {
    for item in &writer.body {
        match item {
            PluginItem::PreHook(pre_fn) => {
                // Validate pre hook signature
                if pre_fn.params.len() != 1 {
                    self.errors.push(SemanticError::new(
                        "WR001",
                        "Writer pre() hook must have exactly one parameter: file: &File",
                        pre_fn.span,
                    ));
                }
            }
            PluginItem::ExitHook(exit_fn) => {
                // Validate exit hook signature for writers
                if exit_fn.params.len() != 3 {
                    self.errors.push(SemanticError::new(
                        "WR002",
                        "Writer exit() hook must have three parameters: program: &Program, state: &PluginState, builder: &CodeBuilder",
                        exit_fn.span,
                    ));
                }
            }
            PluginItem::Function(f) => {
                if f.name.starts_with("visit_") {
                    // Validate visitor methods use &Node not &mut Node for writers
                    for param in &f.params {
                        if let Type::Reference { mutable, .. } = &param.ty {
                            if *mutable {
                                self.errors.push(SemanticError::new(
                                    "WR003",
                                    format!("Writer visitor methods must use &Node not &mut Node: {}", f.name),
                                    param.span,
                                ));
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
}
```

---

## Testing Checklist

### Unit Tests

- [ ] Parse writer with `fn pre()` hook
- [ ] Parse writer with `fn exit()` hook
- [ ] Parse writer with both hooks
- [ ] Validate writer hook signatures
- [ ] Error on `&mut Node` in writer visitor methods

### Codegen Tests

- [ ] Writer with pre() generates Babel `pre(file)` hook
- [ ] Writer with exit() generates Babel `Program.exit` hook
- [ ] Writer without hooks generates visitor only
- [ ] Builder accessible from all visitor methods (closure scope)
- [ ] Exit hook receives `builder` as third parameter
- [ ] SWC writer generates `Visit` trait (not `VisitMut`)
- [ ] SWC writer exit() becomes `finish()` method
- [ ] SWC writer pre() is omitted with comment

### Integration Tests

- [ ] TSX to C# transpiler with file output
- [ ] Writer collects identifiers and exports to metadata
- [ ] Pre-hook accesses original source
- [ ] Exit hook writes file using `fs.writeFileSync`
- [ ] Verbatim blocks work in writer hooks

---

## Migration Guide

### For Existing Writers

If you have a writer without hooks:

**Before:**
```reluxscript
writer MyWriter {
    fn visit_identifier(node: &Identifier) {
        self.builder.append(node.name);
    }
}
```

**After (with finalization):**
```reluxscript
writer MyWriter {
    fn visit_identifier(node: &Identifier) {
        self.builder.append(node.name);
    }

    fn exit(program: &Program, state: &PluginState, builder: &CodeBuilder) {
        babel! {
            const output = builder.toString();
            state.file.metadata.output = output;
            // Or write to file
            fs.writeFileSync('output.txt', output);
        }
    }
}
```

### Breaking Changes

1. **Writer output structure changed:**
   - Before: `module.exports = WriterClass;`
   - After: `module.exports = function({ types: t }) { ... };`

2. **Builder access:**
   - Before: `new WriterClass()` then call methods
   - After: Builder created in closure, accessed via visitor

3. **Usage in tests:**
   - Before: Instantiate class and call visitor methods manually
   - After: Run as Babel plugin, access output from `file.metadata`

---

## Implementation Order

1. ✅ **Phase 1**: Update Babel writer codegen
2. ✅ **Phase 2**: Update SWC writer codegen
3. ✅ **Phase 3**: Create test cases
4. ✅ **Phase 4**: Update specification
5. ✅ **Phase 5**: Add semantic validation

**Estimated Effort:** 4-6 hours

---

## Open Questions

1. **Builder parameter in exit hook:**
   - Pass as third param? ✅ (Recommended)
   - Access via closure only? (Less explicit)

2. **SWC pre() hook:**
   - Silently omit? ✅ (Recommended)
   - Emit warning comment?
   - Error in semantic analysis?

3. **Backward compatibility:**
   - Support old class-based writers?
   - Migration script for existing code?

4. **Builder methods:**
   - Use current minimal set? ✅
   - Add more helpers (indentation, line tracking)?

---

## Success Criteria

✅ Writers generate Babel plugins (not classes)
✅ Pre and exit hooks work as documented in spec
✅ Builder accessible from all visitor methods
✅ SWC writers use `Visit` trait with `finish()` method
✅ All tests pass
✅ Spec matches implementation
✅ No breaking changes to plugin hooks

---

## Related Files

- `reluxscript/src/codegen/babel.rs` - Babel writer codegen
- `reluxscript/src/codegen/swc.rs` - SWC writer codegen
- `reluxscript/src/semantic/resolver.rs` - Hook validation
- `docs/reluxscript-specification.md` - Section 19
- `tests/codegen/test_writer_hooks.rsc` - Test cases
