//! SWC (Rust) code generator for ReluxScript

use crate::parser::*;
use crate::mapping::{get_node_mapping, get_node_mapping_by_visitor};
use super::swc_decorator::{DecoratedProgram, DecoratedTopLevelDecl, DecoratedPlugin, DecoratedWriter, DecoratedPluginItem, DecoratedFnDecl, DecoratedStmt, DecoratedIfStmt, DecoratedBlock};
use super::decorated_ast::{DecoratedPattern, DecoratedPatternKind, DecoratedExpr, DecoratedExprKind};

/// Generator for SWC plugin Rust code
pub struct SwcGenerator {
    output: String,
    indent: usize,
    /// Maps ReluxScript parameter names to SWC names (e.g., "node" -> "n")
    param_renames: std::collections::HashMap<String, String>,
    /// Plugin name for generating nested visitors
    plugin_name: String,
    /// Hoisted inline visitor structs
    hoisted_visitors: Vec<String>,
    /// Variables captured from outer scope (need self. prefix)
    captured_vars: std::collections::HashSet<String>,
    /// Whether json serialization is needed (adds Serialize, Deserialize derives)
    uses_json: bool,
    /// Whether parser module is used (needs helper functions)
    uses_parser: bool,
    /// Whether codegen module is used (needs swc_ecma_codegen imports)
    uses_codegen: bool,
    /// Associated functions (no self parameter) - need Self:: prefix when called
    associated_functions: std::collections::HashSet<String>,
    /// Whether we're generating a writer (uses Visit) vs plugin (uses VisitMut)
    is_writer: bool,
}

impl SwcGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
            param_renames: std::collections::HashMap::new(),
            plugin_name: String::new(),
            hoisted_visitors: Vec::new(),
            captured_vars: std::collections::HashSet::new(),
            uses_json: false,
            uses_parser: false,
            uses_codegen: false,
            associated_functions: std::collections::HashSet::new(),
            is_writer: false,
        }
    }

    /// Generate Rust code for an SWC plugin
    pub fn generate(&mut self, program: &Program) -> String {
        // Check what std types are used
        let (uses_hashmap, uses_hashset) = self.detect_std_collections(program);

        // Check if json, parser, or codegen modules are used (need to set this before struct generation)
        for use_stmt in &program.uses {
            if use_stmt.path == "json" {
                self.uses_json = true;
            }
            if use_stmt.path == "parser" {
                self.uses_parser = true;
            }
            if use_stmt.path == "codegen" {
                self.uses_codegen = true;
            }
        }

        // Emit file header
        self.emit_line("// Generated by ReluxScript compiler");
        self.emit_line("// Do not edit manually");
        self.emit_line("");
        self.emit_line("use swc_common::{Span, DUMMY_SP, SyntaxContext};");
        self.emit_line("use swc_ecma_ast::*;");
        self.emit_line("use swc_ecma_visit::{VisitMut, VisitMutWith};");

        // Add std::collections imports if needed
        if uses_hashmap && uses_hashset {
            self.emit_line("use std::collections::{HashMap, HashSet};");
        } else if uses_hashmap {
            self.emit_line("use std::collections::HashMap;");
        } else if uses_hashset {
            self.emit_line("use std::collections::HashSet;");
        }

        // Process use statements from the program
        for use_stmt in &program.uses {
            // For now, only handle built-in modules (file modules will be handled later)
            if !use_stmt.path.starts_with("./") && !use_stmt.path.starts_with("../") {
                match use_stmt.path.as_str() {
                    "fs" => {
                        self.emit_line("use std::fs;");
                        self.emit_line("use std::path::Path;");
                    }
                    "json" => {
                        self.emit_line("use serde::{Serialize, Deserialize};");
                    self.emit_line("use serde_json;");
                }
                "io" => {
                    self.emit_line("use std::io;");
                    self.emit_line("use std::io::{Read, Write};");
                }
                "path" => {
                    self.emit_line("use std::path::{Path, PathBuf};");
                }
                "parser" => {
                    // Parser module for runtime AST parsing
                    self.emit_line("use swc_common::{FileName, SourceMap};");
                    self.emit_line("use swc_ecma_parser::{Parser, StringInput, Syntax, TsConfig, EsConfig};");
                    self.emit_line("use std::sync::Arc;");
                }
                "codegen" => {
                    // Codegen module for converting AST to code
                    self.emit_line("use swc_ecma_codegen::{text_writer::JsWriter, Emitter, Config as CodegenConfig};");
                    self.emit_line("use swc_common::SourceMap;");
                    self.emit_line("use std::sync::Arc;");
                }
                    other => {
                        // For unknown modules, emit a use statement as-is
                        self.emit_line(&format!("use {};", other));
                    }
                }
            }
        }

        self.emit_line("");

        match &program.decl {
            TopLevelDecl::Plugin(plugin) => self.gen_plugin(plugin),
            TopLevelDecl::Writer(writer) => self.gen_writer(writer),
            TopLevelDecl::Module(module) => self.gen_module(module),
            TopLevelDecl::Interface(_iface) => {
                // TODO: Generate TypeScript interface type
            }
        }

        // Emit hoisted inline visitors at the end
        if !self.hoisted_visitors.is_empty() {
            self.emit_line("");
            self.emit_line("// Hoisted inline visitors for traverse blocks");
            let visitors = std::mem::take(&mut self.hoisted_visitors);
            for visitor in visitors {
                self.emit(&visitor);
                self.emit_line("");
            }
        }

        // Emit parser module helper functions if used
        if self.uses_parser {
            self.emit_line("");
            self.emit_line("// Parser module helper functions");
            self.gen_parser_module_helpers();
        }

        // Emit codegen module helper functions if used
        if self.uses_codegen {
            self.emit_line("");
            self.emit_line("// Codegen module helper functions");
            self.gen_codegen_module_helpers();
        }

        std::mem::take(&mut self.output)
    }

    /// Generate Rust code for an SWC plugin from decorated AST
    pub fn generate_decorated(&mut self, program: &DecoratedProgram) -> String {
        // TODO: Emit file header
        self.emit_line("// Generated by ReluxScript compiler (decorated AST)");
        self.emit_line("// Do not edit manually");
        self.emit_line("");
        self.emit_line("use swc_common::{Span, DUMMY_SP, SyntaxContext};");
        self.emit_line("use swc_ecma_ast::*;");
        self.emit_line("use swc_ecma_visit::{VisitMut, VisitMutWith};");
        self.emit_line("");

        // Generate based on top-level declaration
        match &program.decl {
            DecoratedTopLevelDecl::Plugin(plugin) => self.gen_decorated_plugin(plugin),
            DecoratedTopLevelDecl::Writer(writer) => self.gen_decorated_writer(writer),
            DecoratedTopLevelDecl::Undecorated(decl) => {
                // Fallback to old codegen for undecorated parts
                eprintln!("[WARNING] Falling back to undecorated codegen");
                // For now, just emit a comment
                self.emit_line("// TODO: Undecorated top-level declaration");
            }
        }

        std::mem::take(&mut self.output)
    }

    /// Detect if the program uses HashMap or HashSet from std::collections
    fn detect_std_collections(&self, program: &Program) -> (bool, bool) {
        let mut uses_hashmap = false;
        let mut uses_hashset = false;

        // Check the program for HashMap/HashSet usage
        match &program.decl {
            TopLevelDecl::Plugin(plugin) => {
                for item in &plugin.body {
                    self.detect_collections_in_item(item, &mut uses_hashmap, &mut uses_hashset);
                }
            }
            TopLevelDecl::Writer(writer) => {
                for item in &writer.body {
                    self.detect_collections_in_item(item, &mut uses_hashmap, &mut uses_hashset);
                }
            }
            TopLevelDecl::Module(module) => {
                for item in &module.items {
                    self.detect_collections_in_item(item, &mut uses_hashmap, &mut uses_hashset);
                }
            }
            TopLevelDecl::Interface(_) => {}
        }

        (uses_hashmap, uses_hashset)
    }

    fn detect_collections_in_item(&self, item: &PluginItem, uses_hashmap: &mut bool, uses_hashset: &mut bool) {
        match item {
            PluginItem::Function(func) => {
                self.detect_collections_in_block(&func.body, uses_hashmap, uses_hashset);
            }
            PluginItem::Struct(s) => {
                // Check struct field types for HashMap/HashSet
                for field in &s.fields {
                    self.detect_collections_in_type(&field.ty, uses_hashmap, uses_hashset);
                }
            }
            _ => {}
        }
    }

    fn detect_collections_in_type(&self, ty: &Type, uses_hashmap: &mut bool, uses_hashset: &mut bool) {
        match ty {
            Type::Container { name, type_args } => {
                if name == "HashMap" {
                    *uses_hashmap = true;
                } else if name == "HashSet" {
                    *uses_hashset = true;
                }
                // Recursively check type arguments
                for arg in type_args {
                    self.detect_collections_in_type(arg, uses_hashmap, uses_hashset);
                }
            }
            Type::Array { element } => {
                self.detect_collections_in_type(element, uses_hashmap, uses_hashset);
            }
            Type::Tuple(elements) => {
                for elem in elements {
                    self.detect_collections_in_type(elem, uses_hashmap, uses_hashset);
                }
            }
            Type::Optional(inner) | Type::Reference { inner, .. } => {
                self.detect_collections_in_type(inner, uses_hashmap, uses_hashset);
            }
            _ => {}
        }
    }

    fn detect_collections_in_block(&self, block: &Block, uses_hashmap: &mut bool, uses_hashset: &mut bool) {
        for stmt in &block.stmts {
            self.detect_collections_in_stmt(stmt, uses_hashmap, uses_hashset);
        }
    }

    fn detect_collections_in_stmt(&self, stmt: &Stmt, uses_hashmap: &mut bool, uses_hashset: &mut bool) {
        match stmt {
            Stmt::Let(let_stmt) => {
                self.detect_collections_in_expr(&let_stmt.init, uses_hashmap, uses_hashset);
            }
            Stmt::Const(const_stmt) => {
                self.detect_collections_in_expr(&const_stmt.init, uses_hashmap, uses_hashset);
            }
            Stmt::Expr(expr_stmt) => {
                self.detect_collections_in_expr(&expr_stmt.expr, uses_hashmap, uses_hashset);
            }
            Stmt::If(if_stmt) => {
                self.detect_collections_in_expr(&if_stmt.condition, uses_hashmap, uses_hashset);
                self.detect_collections_in_block(&if_stmt.then_branch, uses_hashmap, uses_hashset);
                for (cond, block) in &if_stmt.else_if_branches {
                    self.detect_collections_in_expr(cond, uses_hashmap, uses_hashset);
                    self.detect_collections_in_block(block, uses_hashmap, uses_hashset);
                }
                if let Some(else_block) = &if_stmt.else_branch {
                    self.detect_collections_in_block(else_block, uses_hashmap, uses_hashset);
                }
            }
            Stmt::For(for_stmt) => {
                self.detect_collections_in_expr(&for_stmt.iter, uses_hashmap, uses_hashset);
                self.detect_collections_in_block(&for_stmt.body, uses_hashmap, uses_hashset);
            }
            Stmt::While(while_stmt) => {
                self.detect_collections_in_expr(&while_stmt.condition, uses_hashmap, uses_hashset);
                self.detect_collections_in_block(&while_stmt.body, uses_hashmap, uses_hashset);
            }
            Stmt::Loop(loop_stmt) => {
                self.detect_collections_in_block(&loop_stmt.body, uses_hashmap, uses_hashset);
            }
            Stmt::Return(ret_stmt) => {
                if let Some(expr) = &ret_stmt.value {
                    self.detect_collections_in_expr(expr, uses_hashmap, uses_hashset);
                }
            }
            _ => {}
        }
    }

    fn detect_collections_in_expr(&self, expr: &Expr, uses_hashmap: &mut bool, uses_hashset: &mut bool) {
        match expr {
            Expr::Ident(ident) => {
                if ident.name == "HashMap" {
                    *uses_hashmap = true;
                } else if ident.name == "HashSet" {
                    *uses_hashset = true;
                }
            }
            Expr::Member(mem) => {
                self.detect_collections_in_expr(&mem.object, uses_hashmap, uses_hashset);
            }
            Expr::Call(call) => {
                self.detect_collections_in_expr(&call.callee, uses_hashmap, uses_hashset);
                for arg in &call.args {
                    self.detect_collections_in_expr(arg, uses_hashmap, uses_hashset);
                }
            }
            Expr::Binary(bin) => {
                self.detect_collections_in_expr(&bin.left, uses_hashmap, uses_hashset);
                self.detect_collections_in_expr(&bin.right, uses_hashmap, uses_hashset);
            }
            Expr::Unary(un) => {
                self.detect_collections_in_expr(&un.operand, uses_hashmap, uses_hashset);
            }
            Expr::Ref(ref_expr) => {
                self.detect_collections_in_expr(&ref_expr.expr, uses_hashmap, uses_hashset);
            }
            Expr::If(if_expr) => {
                self.detect_collections_in_expr(&if_expr.condition, uses_hashmap, uses_hashset);
                self.detect_collections_in_block(&if_expr.then_branch, uses_hashmap, uses_hashset);
                if let Some(else_block) = &if_expr.else_branch {
                    self.detect_collections_in_block(else_block, uses_hashmap, uses_hashset);
                }
            }
            Expr::Closure(closure) => {
                self.detect_collections_in_expr(&closure.body, uses_hashmap, uses_hashset);
            }
            Expr::Block(block) => {
                self.detect_collections_in_block(block, uses_hashmap, uses_hashset);
            }
            Expr::Try(inner) => {
                self.detect_collections_in_expr(inner, uses_hashmap, uses_hashset);
            }
            Expr::VecInit(vec_init) => {
                for elem in &vec_init.elements {
                    self.detect_collections_in_expr(elem, uses_hashmap, uses_hashset);
                }
            }
            Expr::StructInit(struct_init) => {
                for (_, field_expr) in &struct_init.fields {
                    self.detect_collections_in_expr(field_expr, uses_hashmap, uses_hashset);
                }
            }
            Expr::Index(idx) => {
                self.detect_collections_in_expr(&idx.object, uses_hashmap, uses_hashset);
                self.detect_collections_in_expr(&idx.index, uses_hashmap, uses_hashset);
            }
            Expr::Assign(assign) => {
                self.detect_collections_in_expr(&assign.target, uses_hashmap, uses_hashset);
                self.detect_collections_in_expr(&assign.value, uses_hashmap, uses_hashset);
            }
            Expr::Paren(inner) => {
                self.detect_collections_in_expr(inner, uses_hashmap, uses_hashset);
            }
            _ => {}
        }
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_indent(&mut self) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
    }

    fn emit_line(&mut self, s: &str) {
        self.emit_indent();
        self.emit(s);
        self.emit("\n");
    }

    /// Check if a function should be treated as a VisitMut visitor method.
    /// A true visitor must:
    /// 1. Have a name starting with "visit_"
    /// 2. Have no return type (returns ())
    /// 3. Have a mutable reference parameter (&mut T)
    fn is_visitor_method(&self, f: &FnDecl) -> bool {
        // Must be named visit_*
        if !f.name.starts_with("visit_") {
            return false;
        }

        // Must have no return type
        if f.return_type.is_some() {
            return false;
        }

        // Must have at least one parameter that is a mutable reference
        if let Some(first_param) = f.params.first() {
            if let Type::Reference { mutable, .. } = &first_param.ty {
                return *mutable;
            }
        }

        false
    }

    fn gen_plugin(&mut self, plugin: &PluginDecl) {
        // Generate struct definitions first
        for item in &plugin.body {
            if let PluginItem::Struct(s) = item {
                self.gen_struct(s);
            }
        }

        // Generate enum definitions
        for item in &plugin.body {
            if let PluginItem::Enum(e) = item {
                self.gen_enum(e);
            }
        }

        // Check if there's a State struct defined and get its fields
        let state_struct = plugin.body.iter().find_map(|item| {
            if let PluginItem::Struct(s) = item {
                if s.name == "State" {
                    return Some(s);
                }
            }
            None
        });

        // Generate the main plugin struct
        self.emit_line(&format!("pub struct {} {{", plugin.name));
        self.indent += 1;
        if state_struct.is_some() {
            self.emit_line("pub state: State,");
        } else {
            self.emit_line("// Plugin state");
        }
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate impl block with helper functions
        self.emit_line(&format!("impl {} {{", plugin.name));
        self.indent += 1;

        self.emit_line("pub fn new() -> Self {");
        self.indent += 1;
        if let Some(state) = state_struct {
            self.emit_line("Self {");
            self.indent += 1;
            self.emit_line("state: State {");
            self.indent += 1;
            // Initialize state fields with default values
            for field in &state.fields {
                let default_value = self.get_default_value_for_type(&field.ty);
                self.emit_line(&format!("{}: {},", field.name, default_value));
            }
            self.indent -= 1;
            self.emit_line("},");
            self.indent -= 1;
            self.emit_line("}");
        } else {
            self.emit_line("Self {}");
        }
        self.indent -= 1;
        self.emit_line("}");

        // Generate helper functions (non-visitor)
        for item in &plugin.body {
            if let PluginItem::Function(f) = item {
                if !self.is_visitor_method(f) {
                    self.emit_line("");
                    self.gen_helper_function(f);
                }
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate VisitMut impl
        self.emit_line(&format!("impl VisitMut for {} {{", plugin.name));
        self.indent += 1;

        for item in &plugin.body {
            if let PluginItem::Function(f) = item {
                if self.is_visitor_method(f) {
                    self.gen_visitor_method(f);
                }
            }
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn gen_writer(&mut self, writer: &WriterDecl) {
        // Mark that we're generating a writer (uses Visit, not VisitMut)
        self.is_writer = true;

        // Separate items by type
        let mut pre_hook: Option<&FnDecl> = None;
        let mut exit_hook: Option<&FnDecl> = None;
        let mut methods = Vec::new();
        let mut structs = Vec::new();

        for item in &writer.body {
            match item {
                PluginItem::PreHook(f) => pre_hook = Some(f),
                PluginItem::ExitHook(f) => exit_hook = Some(f),
                PluginItem::Function(f) => {
                    // Treat init() and finish() as aliases for pre/exit hooks
                    if f.name == "init" && pre_hook.is_none() {
                        pre_hook = Some(f);
                    } else if f.name == "finish" && exit_hook.is_none() {
                        exit_hook = Some(f);
                    } else {
                        methods.push(f);
                    }
                },
                PluginItem::Struct(s) => structs.push(s),
                _ => {}
            }
        }

        // For writers, use Visit instead of VisitMut
        self.emit_line("use swc_ecma_visit::Visit;");
        self.emit_line("");

        // Find State struct (if any) to flatten its fields into main struct
        let state_struct = structs.iter().find(|s| s.name == "State").cloned();

        // Generate other structs (not State, as we'll flatten it)
        for struct_decl in &structs {
            if struct_decl.name != "State" {
                self.gen_struct(struct_decl);
                self.emit_line("");
            }
        }

        // Generate the writer struct with CodeBuilder + State fields
        self.emit_line(&format!("pub struct {} {{", writer.name));
        self.indent += 1;
        self.emit_line("output: String,");
        self.emit_line("indent_level: usize,");

        // Flatten State struct fields into main struct
        if let Some(state) = state_struct {
            for field in &state.fields {
                let rust_type = self.type_to_rust(&field.ty);
                self.emit_line(&format!("{}: {},", field.name, rust_type));
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate impl block
        self.emit_line(&format!("impl {} {{", writer.name));
        self.indent += 1;

        self.emit_line("pub fn new() -> Self {");
        self.indent += 1;
        self.emit_line("Self {");
        self.indent += 1;
        self.emit_line("output: String::new(),");
        self.emit_line("indent_level: 0,");

        // Initialize State fields with defaults
        if let Some(state) = state_struct {
            for field in &state.fields {
                let default_value = self.get_default_value_for_type(&field.ty);
                self.emit_line(&format!("{}: {},", field.name, default_value));
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // CodeBuilder methods
        self.emit_line("fn append(&mut self, s: &str) {");
        self.indent += 1;
        self.emit_line("self.output.push_str(s);");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        self.emit_line("fn newline(&mut self) {");
        self.indent += 1;
        self.emit_line("self.output.push('\\n');");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        self.emit_line("fn indent(&mut self) {");
        self.indent += 1;
        self.emit_line("self.indent_level += 1;");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        self.emit_line("fn dedent(&mut self) {");
        self.indent += 1;
        self.emit_line("self.indent_level -= 1;");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate finish() method
        if let Some(exit_fn) = exit_hook {
            // Use exit hook as finish method
            self.emit_line("/// Finalize output (from exit hook)");
            self.emit_line("pub fn finish(mut self) -> String {");
            self.indent += 1;

            // Generate exit hook body
            self.gen_block(&exit_fn.body);

            // Always return the output at the end
            self.emit_line("self.output");
            self.indent -= 1;
            self.emit_line("}");
        } else {
            // Default finish
            self.emit_line("pub fn finish(self) -> String {");
            self.indent += 1;
            self.emit_line("self.output");
            self.indent -= 1;
            self.emit_line("}");
        }
        self.emit_line("");

        // Emit comment about pre-hook if present (not supported in SWC)
        if pre_hook.is_some() {
            self.emit_line("// Note: pre() hook not supported in SWC (no source access)");
            self.emit_line("");
        }

        // Generate helper functions (non-visitor methods)
        for method in &methods {
            if !method.name.starts_with("visit_") {
                self.gen_helper_function(method);
                self.emit_line("");
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate Visit impl
        self.emit_line(&format!("impl Visit for {} {{", writer.name));
        self.indent += 1;

        for method in methods {
            if method.name.starts_with("visit_") {
                self.gen_visit_method(method);
            }
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Generate decorated plugin
    fn gen_decorated_plugin(&mut self, plugin: &DecoratedPlugin) {
        self.emit_line(&format!("pub struct {} {{}}", plugin.name));
        self.emit_line("");
        self.emit_line(&format!("impl {} {{", plugin.name));
        self.indent += 1;
        self.emit_indent();
        self.emit_line("pub fn new() -> Self { Self {} }");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate VisitMut implementation
        self.emit_line(&format!("impl VisitMut for {} {{", plugin.name));
        self.indent += 1;

        // TODO: Generate visitor methods from decorated plugin items
        for item in &plugin.body {
            match item {
                DecoratedPluginItem::Function(func) => {
                    self.gen_decorated_visitor_method(func);
                }
                _ => {
                    // TODO: Handle other items
                }
            }
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Generate decorated writer
    fn gen_decorated_writer(&mut self, writer: &DecoratedWriter) {
        // TODO: Similar to plugin but uses Visit instead of VisitMut
        self.emit_line(&format!("// TODO: Decorated writer {}", writer.name));
    }

    /// Generate a visitor method from decorated function
    fn gen_decorated_visitor_method(&mut self, func: &DecoratedFnDecl) {
        // TODO: Generate visitor method with decorated statements
        self.emit_indent();
        self.emit_line(&format!("// TODO: Decorated method {}", func.name));
    }

    fn gen_module(&mut self, module: &ModuleDecl) {
        // Generate standalone module with pub exports
        self.emit_line("//! Generated by ReluxScript compiler");
        self.emit_line("//! Do not edit manually");
        self.emit_line("");

        // Generate structs
        for item in &module.items {
            if let PluginItem::Struct(s) = item {
                self.gen_struct(s);
            }
        }

        // Generate enums
        for item in &module.items {
            if let PluginItem::Enum(e) = item {
                self.gen_enum(e);
            }
        }

        // Generate functions (only pub functions are exported)
        for item in &module.items {
            if let PluginItem::Function(f) = item {
                self.gen_helper_function(f);
                self.emit_line("");
            }
        }
    }

    fn gen_struct(&mut self, s: &StructDecl) {
        if self.uses_json {
            self.emit_line("#[derive(Debug, Clone, Serialize, Deserialize)]");
        } else {
            self.emit_line("#[derive(Debug, Clone)]");
        }
        self.emit_line(&format!("pub struct {} {{", s.name));
        self.indent += 1;
        for field in &s.fields {
            self.emit_indent();
            self.emit(&format!("pub {}: {},\n", field.name, self.type_to_rust(&field.ty)));
        }
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn gen_enum(&mut self, e: &EnumDecl) {
        if self.uses_json {
            self.emit_line("#[derive(Debug, Clone, Serialize, Deserialize)]");
        } else {
            self.emit_line("#[derive(Debug, Clone)]");
        }
        self.emit_line(&format!("pub enum {} {{", e.name));
        self.indent += 1;
        for variant in &e.variants {
            self.emit_indent();
            match &variant.fields {
                EnumVariantFields::Tuple(fields) => {
                    let types: Vec<String> = fields.iter().map(|t| self.type_to_rust(t)).collect();
                    self.emit(&format!("{}({}),\n", variant.name, types.join(", ")));
                }
                EnumVariantFields::Struct(named_fields) => {
                    self.emit(&format!("{} {{\n", variant.name));
                    self.indent += 1;
                    for (field_name, field_type) in named_fields {
                        self.emit_indent();
                        self.emit(&format!("{}: {},\n", field_name, self.type_to_rust(field_type)));
                    }
                    self.indent -= 1;
                    self.emit_indent();
                    self.emit("},\n");
                }
                EnumVariantFields::Unit => {
                    self.emit(&format!("{},\n", variant.name));
                }
            }
        }
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");
    }

    fn gen_helper_function(&mut self, f: &FnDecl) {
        let pub_str = if f.is_pub { "pub " } else { "" };

        // Check if this is an associated function (no self parameter)
        let has_self = f.params.iter().any(|p| p.name == "self");
        if !has_self {
            self.associated_functions.insert(f.name.clone());
        }

        // Generate type parameters: <F, T>
        let type_params = if !f.type_params.is_empty() {
            let params: Vec<String> = f.type_params.iter().map(|p| p.name.clone()).collect();
            format!("<{}>", params.join(", "))
        } else {
            String::new()
        };

        let params: Vec<String> = f.params.iter().map(|p| {
            format!("{}: {}", p.name, self.type_to_rust(&p.ty))
        }).collect();

        let ret_type = f.return_type.as_ref()
            .map(|t| format!(" -> {}", self.type_to_rust(t)))
            .unwrap_or_default();

        // Generate where clause
        let where_clause = if !f.where_clause.is_empty() {
            let predicates: Vec<String> = f.where_clause.iter().map(|p| {
                format!("    {}: {}", p.target, self.type_to_rust(&p.bound))
            }).collect();
            format!("\nwhere\n{}", predicates.join(",\n"))
        } else {
            String::new()
        };

        self.emit_line(&format!("{}fn {}{}({}){}{} {{", pub_str, f.name, type_params, params.join(", "), ret_type, where_clause));
        self.indent += 1;

        // Track parameter types in the environment
        self.type_env.push_scope();
        for param in &f.params {
            let param_ctx = self.type_from_ast(&param.ty);
            #[cfg(debug_assertions)]
            eprintln!("[swc] param {} : {:?} -> swc_type={}",
                param.name, param.ty, param_ctx.swc_type);
            self.type_env.define(&param.name, param_ctx);
        }

        self.gen_block(&f.body);

        self.type_env.pop_scope();
        self.indent -= 1;
        self.emit_line("}");
    }

    /// Generate code for codegen::generate() and codegen::generate_with_options()
    fn gen_codegen_call(&mut self, function_name: &str, args: &[Expr]) {
        match function_name {
            "generate" => {
                // codegen::generate(node) -> codegen_to_string(node)
                if args.is_empty() {
                    self.emit("String::new()");
                    return;
                }

                self.emit("codegen_to_string(");
                self.gen_expr(&args[0]);
                self.emit(")");
            }
            "generate_with_options" => {
                // codegen::generate_with_options(node, options) -> codegen_to_string_with_config(node, config)
                if args.is_empty() {
                    self.emit("String::new()");
                    return;
                }

                self.emit("codegen_to_string_with_config(");
                self.gen_expr(&args[0]);

                // If there's a second argument (options), convert it
                if args.len() > 1 {
                    self.emit(", ");
                    self.gen_codegen_config(&args[1]);
                } else {
                    self.emit(", CodegenConfig::default()");
                }

                self.emit(")");
            }
            _ => {
                // Unknown codegen function, emit as-is
                self.emit(&format!("codegen::{}(", function_name));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(arg);
                }
                self.emit(")");
            }
        }
    }

    /// Convert ReluxScript CodegenOptions struct to SWC codegen Config
    fn gen_codegen_config(&mut self, options_expr: &Expr) {
        // Expected to be a StructInit for CodegenOptions
        if let Expr::StructInit(init) = options_expr {
            if init.name == "CodegenOptions" {
                self.emit("CodegenConfig { ");

                for (field_name, field_value) in &init.fields {
                    // Map ReluxScript field names to SWC codegen Config fields
                    match field_name.as_str() {
                        "minified" => {
                            self.emit("minify: ");
                            self.gen_expr(field_value);
                            self.emit(", ");
                        }
                        "compact" | "semicolons" => {
                            // SWC doesn't have direct equivalents for these
                            // We can add them as comments or ignore
                        }
                        "quotes" => {
                            // SWC doesn't have a quotes option in the same way
                            // Could potentially use it if we extend the config
                        }
                        _ => {
                            // Pass through unknown options
                        }
                    }
                }

                self.emit("..Default::default() }");
                return;
            }
        }

        // Fallback: just use default config
        self.emit("CodegenConfig::default()");
    }

    /// Generate helper functions for the parser module
    fn gen_parser_module_helpers(&mut self) {
        self.emit_line("mod parser {");
        self.indent += 1;
        self.emit_line("use super::*;");
        self.emit_line("");

        // parser::parse_file
        self.emit_line("pub fn parse_file(path: &str) -> Result<Program, String> {");
        self.indent += 1;
        self.emit_line("let source_map = Arc::new(SourceMap::default());");
        self.emit_line("let code = std::fs::read_to_string(path)");
        self.indent += 1;
        self.emit_line(".map_err(|e| format!(\"Failed to read file: {}\", e))?;");
        self.indent -= 1;
        self.emit_line("let file = source_map.new_source_file(");
        self.indent += 1;
        self.emit_line("FileName::Real(path.into()),");
        self.emit_line("code,");
        self.indent -= 1;
        self.emit_line(");");
        self.emit_line("let syntax = Syntax::Typescript(TsConfig {");
        self.indent += 1;
        self.emit_line("tsx: true,");
        self.emit_line("decorators: false,");
        self.emit_line("..Default::default()");
        self.indent -= 1;
        self.emit_line("});");
        self.emit_line("let mut parser = Parser::new(syntax, StringInput::from(&*file), None);");
        self.emit_line("parser.parse_program()");
        self.indent += 1;
        self.emit_line(".map_err(|e| format!(\"Parse error: {:?}\", e))");
        self.indent -= 1;
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // parser::parse
        self.emit_line("pub fn parse(code: &str) -> Result<Program, String> {");
        self.indent += 1;
        self.emit_line("let source_map = Arc::new(SourceMap::default());");
        self.emit_line("let file = source_map.new_source_file(");
        self.indent += 1;
        self.emit_line("FileName::Anon,");
        self.emit_line("code.to_string(),");
        self.indent -= 1;
        self.emit_line(");");
        self.emit_line("let syntax = Syntax::Typescript(TsConfig {");
        self.indent += 1;
        self.emit_line("tsx: true,");
        self.emit_line("decorators: false,");
        self.emit_line("..Default::default()");
        self.indent -= 1;
        self.emit_line("});");
        self.emit_line("let mut parser = Parser::new(syntax, StringInput::from(&*file), None);");
        self.emit_line("parser.parse_program()");
        self.indent += 1;
        self.emit_line(".map_err(|e| format!(\"Parse error: {:?}\", e))");
        self.indent -= 1;
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // parser::parse_with_syntax
        self.emit_line("pub fn parse_with_syntax(code: &str, syntax_type: &str) -> Result<Program, String> {");
        self.indent += 1;
        self.emit_line("let source_map = Arc::new(SourceMap::default());");
        self.emit_line("let file = source_map.new_source_file(");
        self.indent += 1;
        self.emit_line("FileName::Anon,");
        self.emit_line("code.to_string(),");
        self.indent -= 1;
        self.emit_line(");");
        self.emit_line("let syntax = match syntax_type {");
        self.indent += 1;
        self.emit_line("\"TypeScript\" => Syntax::Typescript(TsConfig {");
        self.indent += 1;
        self.emit_line("tsx: true,");
        self.emit_line("decorators: false,");
        self.emit_line("..Default::default()");
        self.indent -= 1;
        self.emit_line("}),");
        self.emit_line("\"JSX\" => Syntax::Es(EsConfig {");
        self.indent += 1;
        self.emit_line("jsx: true,");
        self.emit_line("..Default::default()");
        self.indent -= 1;
        self.emit_line("}),");
        self.emit_line("_ => Syntax::Es(EsConfig::default()),");
        self.indent -= 1;
        self.emit_line("};");
        self.emit_line("let mut parser = Parser::new(syntax, StringInput::from(&*file), None);");
        self.emit_line("parser.parse_program()");
        self.indent += 1;
        self.emit_line(".map_err(|e| format!(\"Parse error: {:?}\", e))");
        self.indent -= 1;
        self.indent -= 1;
        self.emit_line("}");

        self.indent -= 1;
        self.emit_line("}");
    }

    /// Generate helper functions for the codegen module
    fn gen_codegen_module_helpers(&mut self) {
        // Generate a helper function that converts an AST node to a string
        self.emit_line("fn codegen_to_string<N: swc_ecma_visit::Node>(node: &N) -> String {");
        self.indent += 1;
        self.emit_line("let mut buf = vec![];");
        self.emit_line("{");
        self.indent += 1;
        self.emit_line("let cm = Arc::new(SourceMap::default());");
        self.emit_line("let mut emitter = Emitter {");
        self.indent += 1;
        self.emit_line("cfg: CodegenConfig::default(),");
        self.emit_line("cm: cm.clone(),");
        self.emit_line("comments: None,");
        self.emit_line("wr: Box::new(JsWriter::new(cm.clone(), \"\\n\", &mut buf, None)),");
        self.indent -= 1;
        self.emit_line("};");
        self.emit_line("node.emit_with(&mut emitter).unwrap();");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("String::from_utf8(buf).unwrap()");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("");

        // Generate helper function with config
        self.emit_line("fn codegen_to_string_with_config<N: swc_ecma_visit::Node>(node: &N, cfg: CodegenConfig) -> String {");
        self.indent += 1;
        self.emit_line("let mut buf = vec![];");
        self.emit_line("{");
        self.indent += 1;
        self.emit_line("let cm = Arc::new(SourceMap::default());");
        self.emit_line("let mut emitter = Emitter {");
        self.indent += 1;
        self.emit_line("cfg,");
        self.emit_line("cm: cm.clone(),");
        self.emit_line("comments: None,");
        self.emit_line("wr: Box::new(JsWriter::new(cm.clone(), \"\\n\", &mut buf, None)),");
        self.indent -= 1;
        self.emit_line("};");
        self.emit_line("node.emit_with(&mut emitter).unwrap();");
        self.indent -= 1;
        self.emit_line("}");
        self.emit_line("String::from_utf8(buf).unwrap()");
        self.indent -= 1;
        self.emit_line("}");
    }

    fn gen_visitor_method(&mut self, f: &FnDecl) {
        let swc_name = self.visitor_name_to_swc(&f.name);
        let swc_type = self.visitor_name_to_swc_type(&f.name);

        self.emit_line("");
        self.emit_line(&format!("fn {}(&mut self, n: &mut {}) {{", swc_name, swc_type));
        self.indent += 1;

        // Set up parameter renames for visitor methods
        // The first parameter (typically "node") maps to "n"
        if let Some(first_param) = f.params.first() {
            self.param_renames.insert(first_param.name.clone(), "n".to_string());
        }

        // Track the parameter's type in the environment
        // Both "n" and the original parameter name should map to the swc_type
        self.type_env.push_scope();
        let param_ctx = TypeContext {
            reluxscript_type: swc_type.clone(),
            swc_type: swc_type.clone(),
            kind: super::type_context::SwcTypeKind::Struct,
            known_variant: None,
            needs_deref: false,
        };
        self.type_env.define("n", param_ctx.clone());
        if let Some(first_param) = f.params.first() {
            self.type_env.define(&first_param.name, param_ctx);
        }

        // Generate body
        self.gen_block(&f.body);

        // Clear environment and renames
        self.type_env.pop_scope();
        self.param_renames.clear();

        self.indent -= 1;
        self.emit_line("}");
    }

    fn gen_visit_method(&mut self, f: &FnDecl) {
        // For Visit (read-only), parameters are & not &mut
        let mut swc_name = self.visitor_name_to_swc(&f.name);
        // Convert visit_mut_ to visit_ for Visit trait
        if swc_name.starts_with("visit_mut_") {
            swc_name = swc_name.replace("visit_mut_", "visit_");
        }
        let swc_type = self.visitor_name_to_swc_type(&f.name);

        self.emit_line("");
        self.emit_line(&format!("fn {}(&mut self, n: &{}) {{", swc_name, swc_type));
        self.indent += 1;

        // Set up parameter renames for visitor methods
        // The first parameter (typically "node") maps to "n"
        if let Some(first_param) = f.params.first() {
            self.param_renames.insert(first_param.name.clone(), "n".to_string());
        }

        // Track the parameter's type in the environment
        // Both "n" and the original parameter name should map to the swc_type
        self.type_env.push_scope();
        let param_ctx = TypeContext {
            reluxscript_type: swc_type.clone(),
            swc_type: swc_type.clone(),
            kind: super::type_context::SwcTypeKind::Struct,
            known_variant: None,
            needs_deref: false,
        };
        self.type_env.define("n", param_ctx.clone());
        if let Some(first_param) = f.params.first() {
            self.type_env.define(&first_param.name, param_ctx);
        }

        // Generate body - for visitor methods, all statements should have semicolons
        // (they return (), not an implicit value)
        for stmt in &f.body.stmts {
            self.gen_stmt(stmt);
        }

        // Clear environment and renames
        self.type_env.pop_scope();
        self.param_renames.clear();

        self.indent -= 1;
        self.emit_line("}");
    }

    fn visitor_name_to_swc(&self, name: &str) -> String {
        // Use mapping module: visit_call_expression -> visit_mut_call_expr or visit_call_expr
        if let Some(mapping) = get_node_mapping_by_visitor(name) {
            // For writers (Visit trait), use visit_ prefix instead of visit_mut_
            let visitor_name = mapping.swc_visitor.to_string();
            // Check if this is being called in a Visit context (not VisitMut)
            // For now, we'll just return the mapping as-is and handle it in gen_visit_method
            return visitor_name;
        }
        // Fallback for unknown visitor methods
        let stripped = name.strip_prefix("visit_").unwrap_or(name);
        format!("visit_mut_{}", self.to_swc_node_name(stripped))
    }

    fn visitor_name_to_swc_type(&self, name: &str) -> String {
        // Use mapping module to get the SWC type for a visitor method
        if let Some(mapping) = get_node_mapping_by_visitor(name) {
            return mapping.swc.to_string();
        }
        let stripped = name.strip_prefix("visit_").unwrap_or(name);
        self.reluxscript_to_swc_type(stripped)
    }

    fn to_swc_node_name(&self, name: &str) -> String {
        // Convert snake_case ReluxScript node names to SWC visitor method suffixes
        // Try to find a mapping by converting snake_case to PascalCase
        let pascal = name.split('_')
            .map(|part| {
                let mut chars = part.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect::<String>();

        if let Some(mapping) = get_node_mapping(&pascal) {
            // Extract the suffix from swc_visitor (e.g., "visit_mut_call_expr" -> "call_expr")
            mapping.swc_visitor
                .strip_prefix("visit_mut_")
                .unwrap_or(&mapping.swc_visitor)
                .to_string()
        } else {
            // Fallback: apply common transformations
            name.replace("_expression", "_expr")
                .replace("_statement", "_stmt")
                .replace("_declaration", "_decl")
        }
    }

    fn reluxscript_to_swc_type(&self, name: &str) -> String {
        // Convert ReluxScript node names to SWC AST types using mapping module
        // Handle both snake_case and PascalCase inputs

        // Handle primitive type aliases first
        match name {
            "Number" => return "i32".to_string(),
            "Bool" => return "bool".to_string(),
            _ => {}
        }

        // First try direct lookup (PascalCase)
        if let Some(mapping) = get_node_mapping(name) {
            return mapping.swc.to_string();
        }

        // Try converting snake_case to PascalCase
        let pascal: String = name.split('_')
            .map(|s| {
                let mut chars = s.chars();
                match chars.next() {
                    None => String::new(),
                    Some(c) => c.to_uppercase().chain(chars).collect(),
                }
            })
            .collect();

        if let Some(mapping) = get_node_mapping(&pascal) {
            return mapping.swc.to_string();
        }

        // Fallback: return the PascalCase conversion
        pascal
    }

    fn type_to_rust(&self, ty: &Type) -> String {
        match ty {
            Type::Primitive(name) => {
                match name.as_str() {
                    "Str" => "String".to_string(),
                    "()" => "()".to_string(),
                    "Number" => "i32".to_string(),
                    "Bool" => "bool".to_string(),
                    _ => name.clone(),
                }
            }
            Type::Reference { mutable, inner } => {
                let inner_type = self.type_to_rust(inner);
                if *mutable {
                    format!("&mut {}", inner_type)
                } else {
                    format!("&{}", inner_type)
                }
            }
            Type::Container { name, type_args } => {
                let args: Vec<String> = type_args.iter().map(|t| self.type_to_rust(t)).collect();
                format!("{}<{}>", name, args.join(", "))
            }
            Type::Named(name) => {
                // Handle special types
                match name.as_str() {
                    "CodeBuilder" => "String".to_string(),
                    _ => {
                        // Map ReluxScript AST types to SWC types
                        // Don't lowercase - preserve original case for user-defined types
                        self.reluxscript_to_swc_type(name)
                    }
                }
            }
            Type::Array { element } => {
                format!("Vec<{}>", self.type_to_rust(element))
            }
            Type::Tuple(types) => {
                let inner: Vec<String> = types.iter().map(|t| self.type_to_rust(t)).collect();
                format!("({})", inner.join(", "))
            }
            Type::Optional(inner) => {
                format!("Option<{}>", self.type_to_rust(inner))
            }
            Type::Unit => "()".to_string(),
            Type::FnTrait { params, return_type } => {
                let param_types: Vec<String> = params.iter().map(|t| self.type_to_rust(t)).collect();
                let ret = self.type_to_rust(return_type);
                format!("Fn({}) -> {}", param_types.join(", "), ret)
            }
        }
    }

    /// Get a default value for initializing a type
    fn get_default_value_for_type(&self, ty: &Type) -> String {
        match ty {
            Type::Primitive(name) => {
                match name.as_str() {
                    "Str" => "String::new()".to_string(),
                    "Number" => "0".to_string(),
                    "Bool" => "false".to_string(),
                    "()" => "()".to_string(),
                    "i32" | "i64" | "u32" | "u64" | "usize" | "isize" => "0".to_string(),
                    "f32" | "f64" => "0.0".to_string(),
                    "char" => "'\\0'".to_string(),
                    _ => "Default::default()".to_string(),
                }
            }
            Type::Container { name, .. } => {
                match name.as_str() {
                    "Vec" => "Vec::new()".to_string(),
                    "HashMap" => "HashMap::new()".to_string(),
                    "HashSet" => "HashSet::new()".to_string(),
                    "Option" => "None".to_string(),
                    _ => format!("{}::new()", name),
                }
            }
            Type::Optional(_) => "None".to_string(),
            Type::Array { .. } => "Vec::new()".to_string(),
            Type::Named(name) => {
                // Handle special types
                match name.as_str() {
                    "CodeBuilder" => "String::new()".to_string(),
                    _ => "Default::default()".to_string(),
                }
            }
            _ => "Default::default()".to_string(),
        }
    }

    fn gen_block(&mut self, block: &Block) {
        let len = block.stmts.len();
        for (i, stmt) in block.stmts.iter().enumerate() {
            let is_last = i == len - 1;
            self.gen_stmt_with_context(stmt, is_last);
        }
    }

    fn gen_stmt_with_context(&mut self, stmt: &Stmt, is_last_in_block: bool) {
        // If this is the last statement in a block and it's an expression,
        // check if it's actually a return value or just a statement
        match stmt {
            Stmt::Expr(expr_stmt) if is_last_in_block => {
                // Check if this expression produces a meaningful return value
                // Calls to push(), insert(), etc. return () so they need semicolons
                let needs_semicolon = match &expr_stmt.expr {
                    Expr::Call(call) => {
                        // Check if it's a method call to a mutating method
                        if let Expr::Member(mem) = call.callee.as_ref() {
                            matches!(mem.property.as_str(),
                                "push" | "insert" | "remove" | "clear" | "append" |
                                "pop" | "push_str" | "extend" | "drain")
                        } else {
                            false
                        }
                    }
                    Expr::Assign(_) => true,  // Assignments return ()
                    _ => false,
                };

                self.emit_indent();
                self.gen_expr(&expr_stmt.expr);
                if needs_semicolon {
                    self.emit(";");
                }
                self.emit("\n");
            }
            _ => self.gen_stmt(stmt),
        }
    }

    fn gen_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let(let_stmt) => {
                // Determine the type: use explicit annotation if available, else infer
                let var_type = if let Some(ty) = &let_stmt.ty {
                    // Use explicit type annotation
                    self.type_from_ast(ty)
                } else {
                    // Infer the type from the initializer expression
                    self.infer_type(&let_stmt.init)
                };

                self.emit_indent();
                if let_stmt.mutable {
                    self.emit("let mut ");
                } else {
                    self.emit("let ");
                }
                self.gen_pattern(&let_stmt.pattern);
                // Don't emit type annotations for internal temp variables
                // The type environment tracking is what matters
                self.emit(" = ");
                self.gen_expr(&let_stmt.init);
                self.emit(";\n");

                // Track the variable's type in the environment (only for simple identifiers)
                if let Pattern::Ident(name) = &let_stmt.pattern {
                    self.type_env.define(name, var_type);
                }
            }
            Stmt::Const(const_stmt) => {
                self.emit_indent();
                self.emit("const ");
                self.emit(&const_stmt.name);
                if let Some(ty) = &const_stmt.ty {
                    self.emit(&format!(": {}", self.type_to_rust(ty)));
                }
                self.emit(" = ");
                self.gen_expr(&const_stmt.init);
                self.emit(";\n");
            }
            Stmt::Expr(expr_stmt) => {
                self.emit_indent();
                self.gen_expr(&expr_stmt.expr);
                self.emit(";\n");
            }
            Stmt::If(if_stmt) => {
                // Check for if-let pattern first
                if let Some(pattern) = &if_stmt.pattern {
                    self.gen_if_let_stmt(if_stmt, pattern);
                } else if let Some((var_name, type_name, field_path, match_expr)) = self.extract_matches_pattern(&if_stmt.condition) {
                    // Check if condition is matches!(var, Type) or matches!(obj.field, Type)
                    // Look up the variable's type to determine the correct context
                    // Extract the first argument to infer its type
                    let var_type = if let Expr::Call(call) = &if_stmt.condition {
                        if call.args.len() >= 1 {
                            self.infer_type(&call.args[0]).swc_type.clone()
                        } else {
                            "Expr".to_string()
                        }
                    } else {
                        self.type_env.lookup(&var_name)
                            .map(|ctx| ctx.swc_type.clone())
                            .unwrap_or_else(|| "Expr".to_string())
                    };

                    // Generate if let with type narrowing using context
                    let (swc_enum, swc_variant, swc_struct) = get_swc_variant_in_context(&type_name, &var_type);
                    #[cfg(debug_assertions)]
                    eprintln!("[swc] matches!({}, {}) -> var_type={}, enum={}, variant={}, struct={}",
                        match_expr, type_name, var_type, swc_enum, swc_variant, swc_struct);

                    self.emit_indent();
                    // Handle nested patterns like Expr::Lit(Lit::Str(x))
                    let extra_close = if swc_variant.contains('(') { ")" } else { "" };
                    self.emit(&format!("if let {}::{}({}){} = &{} {{\n",
                        swc_enum, swc_variant, var_name, extra_close, match_expr));

                    self.indent += 1;
                    self.type_env.push_scope();

                    // Shadow the variable with narrowed type
                    let narrowed_ctx = TypeContext::narrowed(&type_name, &swc_struct);
                    self.type_env.define(&var_name, narrowed_ctx.clone());

                    // If this was a field access, also register the field refinement
                    if let Some(path) = &field_path {
                        self.type_env.refine_field(path, narrowed_ctx);
                    }

                    self.gen_block(&if_stmt.then_branch);

                    self.type_env.pop_scope();
                    self.indent -= 1;

                    // Handle else-if branches - each might also be a matches! pattern
                    for (cond, block) in &if_stmt.else_if_branches {
                        if let Some((else_var_name, else_type_name, else_field_path, else_match_expr)) = self.extract_matches_pattern(cond) {
                            // This else-if is also a matches! pattern
                            // Infer type from the first argument of matches!
                            let else_var_type = if let Expr::Call(call) = cond {
                                if call.args.len() >= 1 {
                                    self.infer_type(&call.args[0]).swc_type.clone()
                                } else {
                                    "Expr".to_string()
                                }
                            } else {
                                self.type_env.lookup(&else_var_name)
                                    .map(|ctx| ctx.swc_type.clone())
                                    .unwrap_or_else(|| "Expr".to_string())
                            };

                            let (else_swc_enum, else_swc_variant, else_swc_struct) =
                                get_swc_variant_in_context(&else_type_name, &else_var_type);

                            #[cfg(debug_assertions)]
                            eprintln!("[swc] else if matches!({}, {}) -> var_type={}, enum={}, variant={}, struct={}",
                                else_match_expr, else_type_name, else_var_type, else_swc_enum, else_swc_variant, else_swc_struct);

                            self.emit_indent();
                            // Handle nested patterns like Expr::Lit(Lit::Str(x))
                            let else_extra_close = if else_swc_variant.contains('(') { ")" } else { "" };
                            self.emit(&format!("}} else if let {}::{}({}){} = &{} {{\n",
                                else_swc_enum, else_swc_variant, else_var_name, else_extra_close, else_match_expr));

                            self.indent += 1;
                            self.type_env.push_scope();

                            let else_narrowed_ctx = TypeContext::narrowed(&else_type_name, &else_swc_struct);
                            self.type_env.define(&else_var_name, else_narrowed_ctx.clone());

                            // Register field refinement if needed
                            if let Some(path) = &else_field_path {
                                self.type_env.refine_field(path, else_narrowed_ctx);
                            }

                            self.gen_block(block);

                            self.type_env.pop_scope();
                            self.indent -= 1;
                        } else {
                            // Regular else-if condition
                            self.emit_indent();
                            self.emit("} else if ");
                            self.gen_expr(cond);
                            self.emit(" {\n");
                            self.indent += 1;
                            self.gen_block(block);
                            self.indent -= 1;
                        }
                    }

                    // Handle final else branch
                    if let Some(else_block) = &if_stmt.else_branch {
                        self.emit_indent();
                        self.emit("} else {\n");
                        self.indent += 1;
                        self.gen_block(else_block);
                        self.indent -= 1;
                    }

                    self.emit_line("}");
                } else {
                    // Standard if statement
                    self.emit_indent();
                    self.emit("if ");
                    self.gen_expr(&if_stmt.condition);
                    self.emit(" {\n");
                    self.indent += 1;
                    self.gen_block(&if_stmt.then_branch);
                    self.indent -= 1;

                    for (cond, block) in &if_stmt.else_if_branches {
                        self.emit_indent();
                        self.emit("} else if ");
                        self.gen_expr(cond);
                        self.emit(" {\n");
                        self.indent += 1;
                        self.gen_block(block);
                        self.indent -= 1;
                    }

                    if let Some(else_block) = &if_stmt.else_branch {
                        self.emit_indent();
                        self.emit("} else {\n");
                        self.indent += 1;
                        self.gen_block(else_block);
                        self.indent -= 1;
                    }

                    self.emit_line("}");
                }
            }
            Stmt::Match(match_stmt) => {
                self.emit_indent();
                self.emit("match ");
                self.gen_expr(&match_stmt.scrutinee);
                self.emit(" {\n");
                self.indent += 1;
                for arm in &match_stmt.arms {
                    self.emit_indent();
                    self.gen_pattern(&arm.pattern);
                    self.emit(" => ");
                    self.gen_expr(&arm.body);
                    self.emit(",\n");
                }
                self.indent -= 1;
                self.emit_line("}");
            }
            Stmt::For(for_stmt) => {
                self.emit_indent();
                self.emit("for ");
                self.gen_pattern(&for_stmt.pattern);
                self.emit(" in ");
                self.gen_expr(&for_stmt.iter);
                self.emit(" {\n");
                self.indent += 1;

                // Infer the type of the loop variable from the iterator (only for simple identifiers)
                self.type_env.push_scope();
                let iter_type = self.infer_type(&for_stmt.iter);
                let elem_type = self.get_element_type(&iter_type);
                if let Pattern::Ident(var_name) = &for_stmt.pattern {
                    #[cfg(debug_assertions)]
                    eprintln!("[swc] for {} in {:?} -> iter_type={:?}, elem_type={:?}",
                        var_name, for_stmt.iter, iter_type, elem_type);
                    self.type_env.define(var_name, elem_type);
                }

                self.gen_block(&for_stmt.body);

                self.type_env.pop_scope();
                self.indent -= 1;
                self.emit_line("}");
            }
            Stmt::While(while_stmt) => {
                // Check if condition is matches!(var, Type)
                if let Some((var_name, type_name, field_path, match_expr)) = self.extract_matches_pattern(&while_stmt.condition) {
                    // Look up the variable's type to determine the correct context
                    // Infer type from the first argument of matches!
                    let var_type = if let Expr::Call(call) = &while_stmt.condition {
                        if call.args.len() >= 1 {
                            self.infer_type(&call.args[0]).swc_type.clone()
                        } else {
                            "Expr".to_string()
                        }
                    } else {
                        self.type_env.lookup(&var_name)
                            .map(|ctx| ctx.swc_type.clone())
                            .unwrap_or_else(|| "Expr".to_string())
                    };

                    // Generate while let with type narrowing using context
                    let (swc_enum, swc_variant, swc_struct) = get_swc_variant_in_context(&type_name, &var_type);

                    self.emit_indent();
                    self.emit(&format!("while let {}::{}({}) = {} {{\n",
                        swc_enum, swc_variant, var_name, match_expr));

                    self.indent += 1;
                    self.type_env.push_scope();

                    // Shadow the variable with narrowed type
                    let narrowed_ctx = TypeContext::narrowed(&type_name, &swc_struct);
                    self.type_env.define(&var_name, narrowed_ctx.clone());

                    // Register field refinement if needed
                    if let Some(path) = &field_path {
                        self.type_env.refine_field(path, narrowed_ctx);
                    }

                    self.gen_block(&while_stmt.body);

                    self.type_env.pop_scope();
                    self.indent -= 1;
                    self.emit_line("}");
                } else {
                    // Standard while loop
                    self.emit_indent();
                    self.emit("while ");
                    self.gen_expr(&while_stmt.condition);
                    self.emit(" {\n");
                    self.indent += 1;
                    self.gen_block(&while_stmt.body);
                    self.indent -= 1;
                    self.emit_line("}");
                }
            }
            Stmt::Loop(loop_stmt) => {
                self.emit_line("loop {");
                self.indent += 1;
                self.gen_block(&loop_stmt.body);
                self.indent -= 1;
                self.emit_line("}");
            }
            Stmt::Return(ret) => {
                self.emit_indent();
                if let Some(value) = &ret.value {
                    self.emit("return ");
                    self.gen_expr(value);
                    self.emit(";\n");
                } else {
                    self.emit("return;\n");
                }
            }
            Stmt::Break(_) => {
                self.emit_line("break;");
            }
            Stmt::Continue(_) => {
                self.emit_line("continue;");
            }
            Stmt::Traverse(traverse_stmt) => {
                self.gen_traverse_stmt(traverse_stmt);
            }
            Stmt::Function(fn_decl) => {
                // Generate nested function
                self.emit_indent();
                self.emit("fn ");
                self.emit(&fn_decl.name);
                self.emit("(");
                for (i, param) in fn_decl.params.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.emit(&param.name);
                    self.emit(&format!(": {}", self.type_to_rust(&param.ty)));
                }
                self.emit(")");
                if let Some(return_type) = &fn_decl.return_type {
                    self.emit(&format!(" -> {}", self.type_to_rust(return_type)));
                }
                self.emit(" {\n");
                self.indent += 1;
                self.gen_block(&fn_decl.body);
                self.indent -= 1;
                self.emit_indent();
                self.emit("}\n");
            }
            Stmt::Verbatim(verbatim) => {
                // Emit raw code only for Rust target
                match verbatim.target {
                    VerbatimTarget::Rust => {
                        self.emit_indent();
                        self.emit(&verbatim.code);
                        if !verbatim.code.ends_with(';') && !verbatim.code.ends_with('}') {
                            self.emit(";");
                        }
                        self.emit("\n");
                    }
                    VerbatimTarget::JavaScript => {
                        // Skip - this is Babel-only code
                        self.emit_indent();
                        self.emit("// Babel-only code omitted\n");
                    }
                }
            }
        }
    }

    fn gen_if_let_stmt(&mut self, if_stmt: &IfStmt, pattern: &Pattern) {
        // Check if this is a nested enum pattern that needs desugaring
        // e.g., Callee::MemberExpression -> Callee::Expr + Expr::Member
        if let Pattern::Variant { name, inner } = pattern {
            if name == "Callee::MemberExpression" {
                // Desugar into nested if-lets:
                // if let Callee::Expr(__callee_expr) = &node.callee {
                //     if let Expr::Member(ref member) = __callee_expr.as_ref() {
                self.emit_indent();
                self.emit("if let Callee::Expr(__callee_expr) = &");
                self.gen_expr(&if_stmt.condition);
                self.emit(" {\n");
                self.indent += 1;

                self.emit_indent();
                self.emit("if let Expr::Member(");
                if let Some(inner_pat) = inner {
                    self.gen_pattern(inner_pat);
                } else {
                    self.emit("_");
                }
                self.emit(") = __callee_expr.as_ref() {\n");

                self.indent += 1;
                self.type_env.push_scope();

                // Register the binding in type environment
                if let Some(inner_pat) = inner {
                    if let Pattern::Ref { pattern: inner_ident, .. } = inner_pat.as_ref() {
                        if let Pattern::Ident(binding) = inner_ident.as_ref() {
                            let member_type = TypeContext::narrowed("MemberExpression", "MemberExpr");
                            self.type_env.define(binding, member_type);
                        }
                    }
                }

                self.gen_block(&if_stmt.then_branch);

                self.type_env.pop_scope();
                self.indent -= 1;
                self.emit_indent();
                self.emit("}\n");

                self.indent -= 1;

                // Handle else branch
                if let Some(else_block) = &if_stmt.else_branch {
                    self.emit_indent();
                    self.emit("} else {\n");
                    self.indent += 1;
                    self.gen_block(else_block);
                    self.indent -= 1;
                }

                self.emit_line("}");
                return;
            }
        }

        // Standard if-let pattern matching for SWC/Rust
        self.emit_indent();
        self.emit("if let ");
        self.gen_pattern(pattern);
        self.emit(" = ");
        self.gen_expr(&if_stmt.condition);
        self.emit(" {\n");

        self.indent += 1;
        self.type_env.push_scope();

        // If pattern binds a variable, add it to the environment
        if let Pattern::Variant { name, inner } = pattern {
            if let Some(inner_pat) = inner {
                if let Pattern::Ident(binding) = inner_pat.as_ref() {
                    // For Some(x), the binding 'x' gets the inner type
                    // Infer the type of the condition and unwrap it
                    let cond_type = self.infer_type(&if_stmt.condition);
                    let cond_type_str = cond_type.swc_type.clone();
                    let inner_type = if name == "Some" {
                        // Unwrap Option<T> to get T
                        cond_type.unwrap_generic()
                    } else {
                        cond_type
                    };
                    #[cfg(debug_assertions)]
                    eprintln!("[swc] if let {}({}) = ... -> cond_type={}, inner_type={}",
                        name, binding, cond_type_str, inner_type.swc_type);
                    self.type_env.define(binding, inner_type);
                }
            }
        } else if let Pattern::Ident(binding) = pattern {
            let ctx = TypeContext::unknown();
            self.type_env.define(binding, ctx);
        }

        self.gen_block(&if_stmt.then_branch);

        self.type_env.pop_scope();
        self.indent -= 1;

        // Handle else branch
        if let Some(else_block) = &if_stmt.else_branch {
            self.emit_indent();
            self.emit("} else {\n");
            self.indent += 1;
            self.gen_block(else_block);
            self.indent -= 1;
        }

        self.emit_line("}");
    }

    fn gen_traverse_stmt(&mut self, traverse_stmt: &crate::parser::TraverseStmt) {
        match &traverse_stmt.kind {
            crate::parser::TraverseKind::Inline(inline) => {
                // Generate a unique struct name for this inline visitor
                let struct_name = format!("__InlineVisitor_{}", self.hoisted_visitors.len());

                // Check if we have captures (need lifetime parameter)
                let has_captures = !traverse_stmt.captures.is_empty();
                let lifetime = if has_captures { "<'a>" } else { "" };

                // Build the hoisted struct definition
                let mut struct_def = String::new();
                struct_def.push_str(&format!("struct {}{} {{\n", struct_name, lifetime));

                // Add captured variables as reference fields
                for capture in &traverse_stmt.captures {
                    let ref_type = if capture.mutable {
                        "&'a mut"
                    } else {
                        "&'a"
                    };
                    // Look up type from environment, default to i32
                    // For simple integer variables initialized with literals, default to i32
                    let captured_type = if let Some(type_ctx) = self.type_env.lookup(&capture.name) {
                        if type_ctx.swc_type == "Unknown" {
                            "i32".to_string() // Default unknown types to i32
                        } else {
                            type_ctx.swc_type.clone()
                        }
                    } else {
                        "i32".to_string()
                    };
                    struct_def.push_str(&format!("    {}: {} {},\n", capture.name, ref_type, captured_type));
                }

                // Add local state fields
                for let_stmt in &inline.state {
                    // Only add simple identifier patterns as state fields
                    if let Pattern::Ident(name) = &let_stmt.pattern {
                        let ty = if let Some(ref ty) = let_stmt.ty {
                            self.type_to_rust(ty)
                        } else {
                            "i32".to_string() // Default type, should be inferred
                        };
                        struct_def.push_str(&format!("    {}: {},\n", name, ty));
                    }
                }
                struct_def.push_str("}\n\n");

                // Generate impl VisitMut for the struct
                let impl_lifetime = if has_captures { "<'a>" } else { "" };
                struct_def.push_str(&format!("impl{} VisitMut for {}{} {{\n", impl_lifetime, struct_name, lifetime));
                for method in &inline.methods {
                    // Convert visit_xxx to visit_mut_xxx
                    let swc_method = self.visitor_method_to_swc(&method.name);

                    // Get parameter type
                    let param_type = if !method.params.is_empty() {
                        if let crate::parser::Type::Reference { inner, .. } = &method.params[0].ty {
                            if let crate::parser::Type::Named(name) = inner.as_ref() {
                                self.reluxscript_type_to_swc(name)
                            } else {
                                "Expr".to_string()
                            }
                        } else {
                            "Expr".to_string()
                        }
                    } else {
                        "Expr".to_string()
                    };

                    // Get the original parameter name from the method
                    let param_name = if !method.params.is_empty() {
                        &method.params[0].name
                    } else {
                        "n"
                    };

                    struct_def.push_str(&format!("    fn {}(&mut self, {}: &mut {}) {{\n", swc_method, param_name, param_type));

                    // Generate method body with captured variables marked for self. prefix
                    let mut body_gen = SwcGenerator::new();
                    body_gen.indent = 2;
                    // Mark captured variables so they generate as self.var
                    for capture in &traverse_stmt.captures {
                        body_gen.captured_vars.insert(capture.name.clone());
                    }
                    // Also mark local state variables
                    for let_stmt in &inline.state {
                        if let Pattern::Ident(name) = &let_stmt.pattern {
                            body_gen.captured_vars.insert(name.clone());
                        }
                    }
                    body_gen.gen_block(&method.body);
                    struct_def.push_str(&body_gen.output);

                    struct_def.push_str("    }\n");
                }
                struct_def.push_str("}\n");

                self.hoisted_visitors.push(struct_def);

                // Generate instantiation and call at the usage site
                self.emit_indent();
                self.emit(&format!("let mut __visitor = {} {{\n", struct_name));
                self.indent += 1;

                // Initialize captured variables (pass references)
                for capture in &traverse_stmt.captures {
                    self.emit_indent();
                    self.emit(&capture.name);
                    self.emit(": ");
                    if capture.mutable {
                        self.emit("&mut ");
                    } else {
                        self.emit("&");
                    }
                    self.emit(&capture.name);
                    self.emit(",\n");
                }

                // Initialize local state
                for let_stmt in &inline.state {
                    if let Pattern::Ident(name) = &let_stmt.pattern {
                        self.emit_indent();
                        self.emit(name);
                        self.emit(": ");
                        self.gen_expr(&let_stmt.init);
                        self.emit(",\n");
                    }
                }
                self.indent -= 1;
                self.emit_indent();
                self.emit("};\n");

                // Generate visit_mut_with call
                self.emit_indent();
                self.gen_expr(&traverse_stmt.target);
                self.emit(".visit_mut_with(&mut __visitor);\n");
            }
            crate::parser::TraverseKind::Delegated(visitor_name) => {
                // Generate delegation to another visitor
                self.emit_indent();
                self.emit(&format!("let mut __visitor = {}::default();\n", visitor_name));
                self.emit_indent();
                self.gen_expr(&traverse_stmt.target);
                self.emit(".visit_mut_with(&mut __visitor);\n");
            }
        }
    }

    fn visitor_method_to_swc(&self, method_name: &str) -> String {
        // Convert visit_xxx_yyy to visit_mut_xxx_yyy
        if let Some(stripped) = method_name.strip_prefix("visit_") {
            format!("visit_mut_{}", stripped)
        } else {
            method_name.to_string()
        }
    }

    fn reluxscript_type_to_swc(&self, type_name: &str) -> String {
        // Use mapping module to convert ReluxScript AST types to SWC types
        get_node_mapping(type_name)
            .map(|m| m.swc.to_string())
            .unwrap_or_else(|| type_name.to_string())
    }

    /// Extract matches!(var, Type) pattern from an expression
    /// Returns (var_name, type_name, field_path, match_expr) if found
    /// - var_name: the binding variable name (just "id" for "decl.id")
    /// - type_name: the type being matched against
    /// - field_path: Some("decl.id") for field refinement, None for simple var
    /// - match_expr: the full expression to match against ("decl.id" or "var")
    fn extract_matches_pattern(&self, expr: &Expr) -> Option<(String, String, Option<String>, String)> {
        if let Expr::Call(call) = expr {
            if let Expr::Ident(ident) = call.callee.as_ref() {
                if ident.name == "matches!" && call.args.len() == 2 {
                    // First arg can be variable or member expression
                    let (var_name, field_path, match_expr) = match &call.args[0] {
                        Expr::Ident(id) => (id.name.clone(), None, id.name.clone()),
                        Expr::Member(mem) => {
                            // For obj.field, extract the full path for refinement
                            // but use just the field name for the pattern binding
                            if let Expr::Ident(obj_id) = &*mem.object {
                                let path = format!("{}.{}", obj_id.name, mem.property);

                                // Translate field name to SWC using object's type
                                let obj_type = self.type_env.lookup(&obj_id.name)
                                    .map(|ctx| ctx.swc_type.clone())
                                    .unwrap_or_else(|| "Unknown".to_string());
                                let swc_field = get_typed_field_mapping(&obj_type, &mem.property)
                                    .map(|m| m.swc_field.to_string())
                                    .unwrap_or_else(|| mem.property.clone());

                                let match_expr = format!("{}.{}", obj_id.name, swc_field);
                                // Use the field name as the binding variable
                                (mem.property.clone(), Some(path), match_expr)
                            } else {
                                return None;
                            }
                        }
                        _ => return None,
                    };

                    // Second arg should be the type name
                    let type_name = if let Expr::Ident(id) = &call.args[1] {
                        id.name.clone()
                    } else {
                        return None;
                    };

                    return Some((var_name, type_name, field_path, match_expr));
                }
            }
        }
        None
    }

    /// Infer the type of an expression based on context
    fn infer_type(&self, expr: &Expr) -> TypeContext {
        match expr {
            Expr::Ident(ident) => {
                // Look up variable type from environment
                self.type_env.lookup(&ident.name)
                    .cloned()
                    .unwrap_or(TypeContext::unknown())
            }

            Expr::Member(mem) => {
                // 1. Check Refinements First
                if let Expr::Ident(obj) = &*mem.object {
                    if let Some(refined) = self.type_env.lookup_field_refinement(&obj.name, &mem.property) {
                        return refined.clone();
                    }
                }

                // 2. Standard Inference - Get object type, then look up field type
                let obj_type = self.infer_type(&mem.object);
                #[cfg(debug_assertions)]
                eprintln!("[swc] Member: {}.{} -> obj_type={}",
                    match &*mem.object {
                        Expr::Ident(i) => i.name.clone(),
                        _ => "?".to_string(),
                    },
                    mem.property,
                    obj_type.swc_type);
                if let Some(mapping) = get_typed_field_mapping(&obj_type.swc_type, &mem.property) {
                    let (_, kind) = map_reluxscript_to_swc(mapping.result_type_rs);
                    #[cfg(debug_assertions)]
                    eprintln!("[swc]   -> result_type={}", mapping.result_type_swc);
                    TypeContext {
                        reluxscript_type: mapping.result_type_rs.to_string(),
                        swc_type: mapping.result_type_swc.to_string(),
                        kind,
                        known_variant: None,
                        needs_deref: mapping.needs_deref,
                    }
                } else {
                    // Unknown field access
                    #[cfg(debug_assertions)]
                    eprintln!("[swc]   -> no mapping found");
                    TypeContext::unknown()
                }
            }

            Expr::Call(call) => {
                // Check for .clone() which preserves type
                if let Expr::Member(mem) = call.callee.as_ref() {
                    if mem.property == "clone" && call.args.is_empty() {
                        let result = self.infer_type(&mem.object);
                        #[cfg(debug_assertions)]
                        eprintln!("[swc] Call .clone() -> inferred type={}", result.swc_type);
                        return result;
                    }
                }
                // Default: unknown return type
                TypeContext::unknown()
            }

            Expr::VecInit(_) => {
                // Vec initialization - could track element type but for now unknown
                TypeContext::unknown()
            }

            Expr::Ref(ref_expr) => {
                // Reference expression - infer the inner type
                self.infer_type(&ref_expr.expr)
            }

            Expr::Unary(un) => {
                // Unary expression - for Ref/RefMut, infer the inner type
                match un.op {
                    crate::parser::UnaryOp::Ref | crate::parser::UnaryOp::RefMut => {
                        self.infer_type(&un.operand)
                    }
                    _ => TypeContext::unknown(),
                }
            }

            Expr::Index(idx) => {
                // Array/Vec indexing - get the element type
                let container_type = self.infer_type(&idx.object);
                let elem_type = self.get_element_type(&container_type);
                #[cfg(debug_assertions)]
                eprintln!("[swc] Index: container_type={}, elem_type={}",
                    container_type.swc_type, elem_type.swc_type);
                elem_type
            }

            _ => TypeContext::unknown(),
        }
    }

    /// Convert an AST type to a TypeContext
    fn type_from_ast(&self, ty: &Type) -> TypeContext {
        match ty {
            Type::Named(name) => TypeContext::from_reluxscript(name),
            Type::Primitive(name) => TypeContext::from_reluxscript(name),
            Type::Reference { inner, .. } => self.type_from_ast(inner),
            Type::Container { name, type_args } => {
                // Handle Vec, Option, etc. - preserve type arguments
                if type_args.is_empty() {
                    TypeContext::from_reluxscript(name)
                } else {
                    // Build type with arguments, e.g., Vec<i32>
                    let args: Vec<String> = type_args.iter().map(|t| {
                        let ctx = self.type_from_ast(t);
                        ctx.swc_type
                    }).collect();
                    let full_type = format!("{}<{}>", name, args.join(", "));
                    TypeContext {
                        reluxscript_type: full_type.clone(),
                        swc_type: full_type,
                        kind: super::type_context::SwcTypeKind::Unknown,
                        known_variant: None,
                        needs_deref: false,
                    }
                }
            }
            Type::Array { element } => {
                let _elem_type = self.type_from_ast(element);
                TypeContext::unknown() // Array type - could be improved
            }
            Type::Tuple(_) => TypeContext::unknown(),
            Type::Optional(inner) => self.type_from_ast(inner),
            Type::Unit => TypeContext::unknown(),
            Type::FnTrait { .. } => TypeContext::unknown(),
        }
    }

    /// Get the element type from a collection type (Vec, array, etc.)
    fn get_element_type(&self, container_type: &TypeContext) -> TypeContext {
        // Check if the swc_type represents a Vec or array
        let swc_type = &container_type.swc_type;

        // Handle Vec<T> - extract T
        if swc_type.starts_with("Vec<") && swc_type.ends_with(">") {
            let inner = &swc_type[4..swc_type.len()-1];
            return TypeContext {
                reluxscript_type: inner.to_string(),
                swc_type: inner.to_string(),
                kind: super::type_context::classify_swc_type(inner),
                known_variant: None,
                needs_deref: false,
            };
        }

        // For unknown collections, return unknown
        TypeContext::unknown()
    }

    // ============================================================================
    // DECORATED AST GENERATION (New, metadata-driven)
    // ============================================================================

    /// Generate pattern from decorated AST (uses metadata)
    fn gen_decorated_pattern(&mut self, pattern: &DecoratedPattern) {
        // Use metadata.swc_pattern directly - no inference needed!
        self.emit(&pattern.metadata.swc_pattern);

        // Handle inner patterns recursively
        match &pattern.kind {
            DecoratedPatternKind::Variant { inner: Some(inner_pat), .. } => {
                self.emit("(");
                self.gen_decorated_pattern(inner_pat);
                self.emit(")");
            }
            DecoratedPatternKind::Tuple(patterns) => {
                self.emit("(");
                for (i, p) in patterns.iter().enumerate() {
                    if i > 0 { self.emit(", "); }
                    self.gen_decorated_pattern(p);
                }
                self.emit(")");
            }
            DecoratedPatternKind::Struct { fields, .. } => {
                self.emit(" { ");
                for (i, (name, p)) in fields.iter().enumerate() {
                    if i > 0 { self.emit(", "); }
                    self.emit(name);
                    self.emit(": ");
                    self.gen_decorated_pattern(p);
                }
                self.emit(" }");
            }
            _ => {
                // Other pattern kinds don't need special handling
            }
        }
    }

    /// Generate expression from decorated AST (uses metadata)
    fn gen_decorated_expr(&mut self, expr: &DecoratedExpr) {
        match &expr.kind {
            DecoratedExprKind::Literal(lit) => self.gen_literal(lit),

            DecoratedExprKind::Ident { name, ident_metadata } => {
                // Metadata tells us if we need &*sym or just name
                if let Some(ref deref) = ident_metadata.deref_pattern {
                    self.emit(deref);
                }
                self.emit(name);
                if ident_metadata.use_sym {
                    self.emit(".sym");
                }
            }

            DecoratedExprKind::Binary { left, op, right, binary_metadata } => {
                self.emit("(");
                if binary_metadata.left_needs_deref {
                    self.emit("&*");
                }
                self.gen_decorated_expr(left);
                self.emit(&format!(" {} ", self.binary_op_to_rust(op)));
                if binary_metadata.right_needs_deref {
                    self.emit("&*");
                }
                self.gen_decorated_expr(right);
                self.emit(")");
            }

            DecoratedExprKind::Member { object, property, field_metadata, .. } => {
                self.gen_decorated_expr(object);
                self.emit(".");
                // Use the SWC field name from metadata!
                self.emit(&field_metadata.swc_field_name);

                // Apply accessor strategy from metadata
                match &field_metadata.accessor {
                    super::swc_metadata::FieldAccessor::BoxedAsRef => {
                        self.emit(".as_ref()");
                    }
                    _ => {
                        // Other accessors handled differently
                    }
                }
            }

            DecoratedExprKind::Undecorated(original_expr) => {
                // Fallback for expressions that haven't been decorated yet
                self.gen_expr(original_expr);
            }

            _ => {
                // TODO: Implement other expression kinds
                self.emit("/* TODO: decorated expr */");
            }
        }
    }

    /// Generate if-let statement from decorated AST
    fn gen_decorated_if_let_stmt(&mut self, if_stmt: &DecoratedIfStmt) {
        self.emit_indent();
        self.emit("if let ");

        if let Some(ref pattern) = if_stmt.pattern {
            self.gen_decorated_pattern(pattern);
        }

        self.emit(" = ");
        self.gen_decorated_expr(&if_stmt.condition);
        self.emit(" {\n");

        self.indent += 1;
        self.gen_decorated_block(&if_stmt.then_branch);
        self.indent -= 1;

        if let Some(ref else_branch) = if_stmt.else_branch {
            self.emit_indent();
            self.emit("} else {\n");
            self.indent += 1;
            self.gen_decorated_block(else_branch);
            self.indent -= 1;
        }

        self.emit_line("}");
    }

    /// Generate block from decorated AST
    fn gen_decorated_block(&mut self, block: &DecoratedBlock) {
        for stmt in &block.stmts {
            self.gen_decorated_stmt(stmt);
        }
    }

    /// Generate statement from decorated AST
    fn gen_decorated_stmt(&mut self, stmt: &DecoratedStmt) {
        match stmt {
            DecoratedStmt::If(if_stmt) => {
                self.gen_decorated_if_let_stmt(if_stmt);
            }
            DecoratedStmt::Undecorated(original_stmt) => {
                // Fallback for statements that haven't been decorated yet
                self.gen_stmt(original_stmt);
            }
        }
    }

    // ============================================================================
    // ORIGINAL AST GENERATION (Old, will be deprecated)
    // ============================================================================

    fn gen_pattern(&mut self, pattern: &Pattern) {
        match pattern {
            Pattern::Literal(lit) => self.gen_literal(lit),
            Pattern::Ident(name) => self.emit(name),
            Pattern::Wildcard => self.emit("_"),
            Pattern::Tuple(patterns) => {
                self.emit("(");
                for (i, pat) in patterns.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_pattern(pat);
                }
                self.emit(")");
            }
            Pattern::Array(patterns) => {
                self.emit("[");
                for (i, pat) in patterns.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_pattern(pat);
                }
                self.emit("]");
            }
            Pattern::Object(_) => {
                // Rust doesn't have object destructuring, use wildcard
                self.emit("_");
            }
            Pattern::Rest(_) => {
                // Rest patterns in Rust use ..
                self.emit("..");
            }
            Pattern::Struct { name, fields } => {
                self.emit(name);
                self.emit(" { ");
                for (i, (fname, fpat)) in fields.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.emit(fname);
                    self.emit(": ");
                    self.gen_pattern(fpat);
                }
                self.emit(" }");
            }
            Pattern::Variant { name, inner } => {
                // Map ReluxScript type names to SWC types (e.g., Expression::Identifier -> Expr::Ident)
                let swc_name = if name.contains("::") {
                    let parts: Vec<&str> = name.split("::").collect();
                    if parts.len() == 2 {
                        let enum_name = self.reluxscript_to_swc_type(parts[0]);
                        let variant_name = self.reluxscript_to_swc_type(parts[1]);
                        format!("{}::{}", enum_name, variant_name)
                    } else {
                        name.clone()
                    }
                } else {
                    // Handle standalone variant names (Some, None, Ok, Err)
                    name.clone()
                };
                self.emit(&swc_name);
                if let Some(inner_pat) = inner {
                    self.emit("(");
                    self.gen_pattern(inner_pat);
                    self.emit(")");
                }
            }
            Pattern::Or(patterns) => {
                for (i, p) in patterns.iter().enumerate() {
                    if i > 0 {
                        self.emit(" | ");
                    }
                    self.gen_pattern(p);
                }
            }
            Pattern::Ref { pattern: inner, .. } => {
                // Preserve ref in Rust
                self.emit("ref ");
                self.gen_pattern(inner);
            }
        }
    }

    fn gen_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::Literal(lit) => self.gen_literal(lit),
            Expr::Ident(ident) => {
                match ident.name.as_str() {
                    "self" => self.emit("self"),
                    _ => {
                        // Check for parameter renames (e.g., "node" -> "n")
                        let output = if let Some(renamed) = self.param_renames.get(&ident.name) {
                            renamed.clone()
                        } else {
                            ident.name.clone()
                        };
                        // Check if this is a captured variable (needs self. prefix)
                        if self.captured_vars.contains(&ident.name) {
                            self.emit(&format!("self.{}", output));
                        } else {
                            self.emit(&output);
                        }
                    }
                }
            }
            Expr::Binary(bin) => {
                self.emit("(");
                self.gen_expr(&bin.left);
                self.emit(&format!(" {} ", self.binary_op_to_rust(&bin.op)));
                self.gen_expr(&bin.right);
                self.emit(")");
            }
            Expr::Unary(un) => {
                match un.op {
                    UnaryOp::Not => {
                        self.emit("!");
                        self.gen_expr(&un.operand);
                    }
                    UnaryOp::Neg => {
                        self.emit("-");
                        self.gen_expr(&un.operand);
                    }
                    UnaryOp::Deref => {
                        self.emit("*");
                        self.gen_expr(&un.operand);
                    }
                    UnaryOp::Ref => {
                        self.emit("&");
                        self.gen_expr(&un.operand);
                    }
                    UnaryOp::RefMut => {
                        self.emit("&mut ");
                        self.gen_expr(&un.operand);
                    }
                }
            }
            Expr::Call(call) => {
                // Check for matches! macro
                if let Expr::Ident(ident) = call.callee.as_ref() {
                    if ident.name == "matches!" && call.args.len() >= 2 {
                        self.gen_matches_macro(&call.args[0], &call.args[1]);
                        return;
                    }
                    // Check if this is a call to an associated function (needs Self:: prefix)
                    if self.associated_functions.contains(&ident.name) {
                        self.emit("Self::");
                        self.emit(&ident.name);
                        self.emit("(");
                        for (i, arg) in call.args.iter().enumerate() {
                            if i > 0 {
                                self.emit(", ");
                            }
                            self.gen_expr(arg);
                        }
                        self.emit(")");
                        return;
                    }
                    // Check for format! macro - pass through as-is
                    if (ident.name == "format!" || ident.name == "format") && !call.args.is_empty() {
                        self.emit("format!(");
                        for (i, arg) in call.args.iter().enumerate() {
                            if i > 0 {
                                self.emit(", ");
                            }
                            self.gen_expr(arg);
                        }
                        self.emit(")");
                        return;
                    }
                    // Check for vec! macro - pass through as-is
                    if ident.name == "vec!" {
                        self.emit("vec![");
                        for (i, arg) in call.args.iter().enumerate() {
                            if i > 0 {
                                self.emit(", ");
                            }
                            self.gen_expr(arg);
                        }
                        self.emit("]");
                        return;
                    }
                    // Check for panic! macro - pass through as-is
                    if ident.name == "panic!" {
                        self.emit("panic!(");
                        for (i, arg) in call.args.iter().enumerate() {
                            if i > 0 {
                                self.emit(", ");
                            }
                            self.gen_expr(arg);
                        }
                        self.emit(")");
                        return;
                    }
                }

                // Check for CodeBuilder methods
                if let Expr::Member(mem) = call.callee.as_ref() {
                    // CodeBuilder::new() -> String::new()
                    if let Expr::Ident(type_name) = mem.object.as_ref() {
                        if type_name.name == "CodeBuilder" && mem.property == "new" {
                            self.emit("String::new()");
                            return;
                        }
                    }

                    // builder.append(s) -> builder.push_str(s)
                    if mem.property == "append" {
                        // Check if object is CodeBuilder type
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            self.gen_expr(&mem.object);
                            self.emit(".push_str(");
                            if !call.args.is_empty() {
                                self.gen_expr(&call.args[0]);
                            }
                            self.emit(")");
                            return;
                        }
                    }

                    // builder.append_line(s) -> builder.push_str(s); builder.push_str("\n")
                    if mem.property == "append_line" {
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            self.emit("{ ");
                            self.gen_expr(&mem.object);
                            self.emit(".push_str(");
                            if !call.args.is_empty() {
                                self.gen_expr(&call.args[0]);
                            }
                            self.emit("); ");
                            self.gen_expr(&mem.object);
                            self.emit(".push_str(\"\\n\"); }");
                            return;
                        }
                    }

                    // builder.newline() -> builder.push_str("\n")
                    if mem.property == "newline" {
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            self.gen_expr(&mem.object);
                            self.emit(".push_str(\"\\n\")");
                            return;
                        }
                    }

                    // builder.indent() - no-op for now (would need state tracking)
                    if mem.property == "indent" {
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            // TODO: Implement indent tracking
                            self.emit("()");
                            return;
                        }
                    }

                    // builder.dedent() - no-op for now
                    if mem.property == "dedent" {
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            // TODO: Implement indent tracking
                            self.emit("()");
                            return;
                        }
                    }

                    // builder.to_string() -> builder.clone()
                    if mem.property == "to_string" {
                        let obj_type = self.infer_type(&mem.object);
                        if obj_type.swc_type == "CodeBuilder" {
                            self.gen_expr(&mem.object);
                            self.emit(".clone()");
                            return;
                        }
                    }

                    // Check for codegen::generate() and codegen::generate_with_options()
                    if mem.is_path {
                        if let Expr::Ident(module_ident) = mem.object.as_ref() {
                            if module_ident.name == "codegen" {
                                self.gen_codegen_call(&mem.property, &call.args);
                                return;
                            }
                        }
                    }
                }

                // Check for visitor traversal methods
                if let Expr::Member(mem) = call.callee.as_ref() {
                    let prop = &mem.property;
                    // visit_children(self) -> swc_ecma_visit::VisitWith::visit_children_with(node, self) for writers
                    //                      -> n.visit_mut_children_with(self) for plugins
                    if prop == "visit_children" {
                        if self.is_writer {
                            // Use fully qualified syntax for Visit trait
                            self.emit("swc_ecma_visit::VisitWith::visit_children_with(");
                            self.gen_expr(&mem.object);
                            self.emit(", self)");
                        } else {
                            self.gen_expr(&mem.object);
                            self.emit(".visit_mut_children_with(self)");
                        }
                        return;
                    }
                    // visit_with(self) -> n.visit_with(self) for writers, n.visit_mut_with(self) for plugins
                    if prop == "visit_with" {
                        self.gen_expr(&mem.object);
                        if self.is_writer {
                            self.emit(".visit_with(self)");
                        } else {
                            self.emit(".visit_mut_with(self)");
                        }
                        return;
                    }
                }

                self.gen_expr(&call.callee);
                self.emit("(");
                for (i, arg) in call.args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(arg);
                }
                self.emit(")");
            }
            Expr::Member(mem) => {
                // Check for nested member access that needs unwrapping
                // e.g., node.callee.name or member.key.name
                if mem.property == "name" || mem.property == "sym" {
                    if let Expr::Member(inner) = mem.object.as_ref() {
                        let inner_prop = &inner.property;
                        // Handle callee.name -> need to unwrap Callee::Expr then Expr::Ident
                        if inner_prop == "callee" {
                            // Generate: if let Callee::Expr(e) = &obj.callee { if let Expr::Ident(i) = e.as_ref() { i.sym.clone() } }
                            // For now, emit a simpler pattern that assumes Ident
                            self.emit("{ let __callee = &");
                            self.gen_expr(&inner.object);
                            self.emit(".callee; match __callee { Callee::Expr(e) => match e.as_ref() { Expr::Ident(i) => i.sym.clone(), _ => \"\".into() }, _ => \"\".into() } }");
                            return;
                        }
                        // Handle key.name -> need to unwrap Box<Expr> then Expr::Ident
                        if inner_prop == "key" {
                            self.emit("{ match ");
                            self.gen_expr(&inner.object);
                            self.emit(".key.as_ref() { Expr::Ident(i) => i.sym.clone(), _ => \"\".into() } }");
                            return;
                        }
                    }
                }

                // Special case: self.builder in writers becomes just "self"
                if let Expr::Ident(obj_ident) = mem.object.as_ref() {
                    if obj_ident.name == "self" && mem.property == "builder" {
                        // In writer context, self.builder -> self (writer has methods directly)
                        self.emit("self");
                        return;
                    }
                    // Special case: self.state in writers becomes self (State is flattened)
                    if obj_ident.name == "self" && mem.property == "state" {
                        self.emit("self");
                        return;
                    }
                }
                // Special case: self.state.builder becomes self (nested member access)
                if let Expr::Member(inner_mem) = mem.object.as_ref() {
                    if let Expr::Ident(obj_ident) = inner_mem.object.as_ref() {
                        if obj_ident.name == "self" && inner_mem.property == "state" && mem.property == "builder" {
                            self.emit("self");
                            return;
                        }
                    }
                }

                // Simple member access
                // Translate module names
                if let Expr::Ident(ident) = &*mem.object {
                    // Translate json:: to serde_json::
                    if ident.name == "json" && mem.is_path {
                        self.emit("serde_json");
                    } else {
                        self.gen_expr(&mem.object);
                    }
                } else {
                    self.gen_expr(&mem.object);
                }
                // Use :: for path expressions, . for member access
                self.emit(if mem.is_path { "::" } else { "." });
                // Map ReluxScript field names to SWC field names using type context
                let obj_type = self.infer_type(&mem.object);
                let is_ast_type = !matches!(obj_type.kind, super::type_context::SwcTypeKind::Unknown);
                let swc_field = if let Some(mapping) = get_typed_field_mapping(&obj_type.swc_type, &mem.property) {
                    mapping.swc_field
                } else if is_ast_type {
                    // Only apply fallback mappings for known AST types, not user-defined types
                    match mem.property.as_str() {
                        // Identifier.name -> Ident.sym
                        "name" => "sym",
                        // MemberExpression.property -> MemberExpr.prop
                        "property" => "prop",
                        // MemberExpression.object -> MemberExpr.obj (needs Box unwrap)
                        "object" => "obj",
                        // CallExpression.arguments -> CallExpr.args
                        "arguments" => "args",
                        // CallExpression.callee -> CallExpr.callee (needs Box unwrap)
                        "callee" => "callee",
                        // ArrayPattern.elements / ArrayExpression.elements -> elems
                        "elements" => "elems",
                        _ => &mem.property,
                    }
                } else {
                    // Unknown type (likely user-defined) - don't map field names
                    &mem.property
                };
                self.emit(swc_field);
            }
            Expr::Index(idx) => {
                // Check if this is a slice with range syntax
                if let Expr::Range(range) = idx.index.as_ref() {
                    // Convert name[start..end] to &name[start..end]
                    self.emit("&");
                    self.gen_expr(&idx.object);
                    self.emit("[");
                    if let Some(start) = &range.start {
                        self.gen_expr(start);
                    } else {
                        self.emit("0");
                    }
                    self.emit("..");
                    if let Some(end) = &range.end {
                        self.gen_expr(end);
                    }
                    self.emit("]");
                } else {
                    // Regular index access
                    self.gen_expr(&idx.object);
                    self.emit("[");
                    self.gen_expr(&idx.index);
                    self.emit("]");
                }
            }
            Expr::StructInit(init) => {
                // Map ReluxScript AST types to SWC types
                // Don't lowercase - preserve original case for user-defined types
                let swc_type = self.reluxscript_to_swc_type(&init.name);

                // Handle special SWC struct field mappings
                let is_ident = swc_type == "Ident";
                let is_call_expr = swc_type == "CallExpr";
                let is_literal = swc_type == "Lit";

                self.emit(&swc_type);
                self.emit(" { ");

                // Special case: Use Ident::new() constructor instead of struct literal
                if is_ident {
                    // Ident should use the constructor: Ident::new(name.into(), DUMMY_SP)
                    // This ensures all required fields (sym, span, ctxt, optional) are properly initialized
                    let mut name_value = None;
                    for (field_name, field_value) in &init.fields {
                        if field_name == "name" {
                            name_value = Some(field_value);
                            break;
                        }
                    }

                    if let Some(name_val) = name_value {
                        // Rewrite as Ident::new() call
                        self.output.truncate(self.output.len() - " { ".len()); // Remove " { "
                        self.emit("::new(");
                        self.gen_expr(name_val);
                        self.emit(".into(), DUMMY_SP, SyntaxContext::empty())");
                        return;
                    }
                }

                for (i, (name, value)) in init.fields.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }

                    // Map field names for SWC types
                    if is_ident && name == "name" {
                        // This branch should not be reached due to the special case above
                        self.emit("sym: ");
                        self.gen_expr(value);
                        self.emit(".into(), span: DUMMY_SP");
                    } else if is_call_expr && name == "callee" {
                        // CallExpr.callee is Callee enum
                        self.emit("callee: Callee::Expr(Box::new(Expr::Ident(Ident::new(");
                        // Extract the name from the nested Identifier
                        if let Expr::StructInit(nested) = value {
                            for (nested_name, nested_val) in &nested.fields {
                                if nested_name == "name" {
                                    self.gen_expr(nested_val);
                                }
                            }
                        } else {
                            self.gen_expr(value);
                        }
                        self.emit(".into(), DUMMY_SP, SyntaxContext::empty()))))");
                    } else if is_call_expr && name == "arguments" {
                        // CallExpr.args is Vec<ExprOrSpread>
                        self.emit("args: vec![]"); // Simplified for now
                        // TODO: properly handle ExprOrSpread
                    } else if is_literal && name == "value" {
                        // Literal needs proper Lit enum variant
                        self.emit("value: Lit::Num(Number { value: ");
                        self.gen_expr(value);
                        self.emit(".0, span: DUMMY_SP, raw: None })");
                    } else {
                        self.emit(name);
                        self.emit(": ");
                        self.gen_expr(value);
                    }
                }

                // Add required fields for CallExpr
                if is_call_expr {
                    self.emit(", span: DUMMY_SP, ..Default::default()");
                }

                self.emit(" }");
            }
            Expr::VecInit(vec) => {
                self.emit("vec![");
                for (i, elem) in vec.elements.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(elem);
                }
                self.emit("]");
            }
            Expr::If(if_expr) => {
                // Check if this is an if-let expression
                if let Some(pattern) = &if_expr.pattern {
                    self.emit("if let ");
                    self.gen_pattern(pattern);
                    self.emit(" = ");
                    self.gen_expr(&if_expr.condition);
                } else {
                    self.emit("if ");
                    self.gen_expr(&if_expr.condition);
                }
                self.emit(" {");
                // Check if this is a simple single-expression if (no semicolons needed)
                let is_simple = if_expr.then_branch.stmts.len() == 1
                    && matches!(if_expr.then_branch.stmts[0], Stmt::Expr(_))
                    && if_expr.else_branch.as_ref().map_or(true, |b| b.stmts.len() == 1 && matches!(b.stmts[0], Stmt::Expr(_)));

                if is_simple {
                    self.emit(" ");
                    // For simple if-expressions, just emit the expression without indentation
                    for stmt in &if_expr.then_branch.stmts {
                        if let Stmt::Expr(expr_stmt) = stmt {
                            self.gen_expr(&expr_stmt.expr);
                        }
                    }
                    self.emit(" }");
                    if let Some(else_block) = &if_expr.else_branch {
                        self.emit(" else { ");
                        for stmt in &else_block.stmts {
                            if let Stmt::Expr(expr_stmt) = stmt {
                                self.gen_expr(&expr_stmt.expr);
                            }
                        }
                        self.emit(" }");
                    }
                } else {
                    self.emit("\n");
                    self.indent += 1;
                    let then_len = if_expr.then_branch.stmts.len();
                    for (i, stmt) in if_expr.then_branch.stmts.iter().enumerate() {
                        self.gen_stmt_with_context(stmt, i == then_len - 1);
                    }
                    self.indent -= 1;
                    self.emit_indent();
                    self.emit("}");
                    if let Some(else_block) = &if_expr.else_branch {
                        self.emit(" else {\n");
                        self.indent += 1;
                        let else_len = else_block.stmts.len();
                        for (i, stmt) in else_block.stmts.iter().enumerate() {
                            self.gen_stmt_with_context(stmt, i == else_len - 1);
                        }
                        self.indent -= 1;
                        self.emit_indent();
                        self.emit("}");
                    }
                }
            }
            Expr::Match(match_expr) => {
                self.emit("match ");
                self.gen_expr(&match_expr.scrutinee);
                self.emit(" { ");
                for arm in &match_expr.arms {
                    self.gen_pattern(&arm.pattern);
                    self.emit(" => ");
                    self.gen_expr(&arm.body);
                    self.emit(", ");
                }
                self.emit("}");
            }
            Expr::Closure(closure) => {
                self.emit("|");
                self.emit(&closure.params.join(", "));
                self.emit("| ");
                self.gen_expr(&closure.body);
            }
            Expr::Ref(ref_expr) => {
                if ref_expr.mutable {
                    self.emit("&mut ");
                } else {
                    self.emit("&");
                }
                self.gen_expr(&ref_expr.expr);
            }
            Expr::Deref(deref) => {
                self.emit("*");
                self.gen_expr(&deref.expr);
            }
            Expr::Assign(assign) => {
                self.gen_expr(&assign.target);
                self.emit(" = ");
                self.gen_expr(&assign.value);
            }
            Expr::CompoundAssign(compound) => {
                self.gen_expr(&compound.target);
                self.emit(&format!(" {}= ", self.compound_op_to_rust(&compound.op)));
                self.gen_expr(&compound.value);
            }
            Expr::Range(range) => {
                if let Some(start) = &range.start {
                    self.gen_expr(start);
                }
                if range.inclusive {
                    self.emit("..=");
                } else {
                    self.emit("..");
                }
                if let Some(end) = &range.end {
                    self.gen_expr(end);
                }
            }
            Expr::Block(block) => {
                // Block expression
                self.emit("{\n");
                self.indent += 1;
                self.gen_block(block);
                self.indent -= 1;
                self.emit_indent();
                self.emit("}");
            }
            Expr::Try(inner) => {
                // Try operator: expr?
                self.gen_expr(inner);
                self.emit("?");
            }
            Expr::Paren(inner) => {
                self.emit("(");
                self.gen_expr(inner);
                self.emit(")");
            }
            Expr::Tuple(elements) => {
                // Tuples stay as tuples in Rust
                self.emit("(");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(elem);
                }
                self.emit(")");
            }

            Expr::Matches(matches_expr) => {
                // Generate matches! macro in Rust
                self.emit("matches!(");
                self.gen_expr(&matches_expr.scrutinee);
                self.emit(", ");
                self.gen_pattern(&matches_expr.pattern);
                self.emit(")");
            }

            Expr::Return(value) => {
                self.emit("return");
                if let Some(ref expr) = value {
                    self.emit(" ");
                    self.gen_expr(expr);
                }
            }

            Expr::Break => {
                self.emit("break");
            }

            Expr::Continue => {
                self.emit("continue");
            }
        }
    }

    fn gen_literal(&mut self, lit: &Literal) {
        match lit {
            Literal::String(s) => {
                self.emit(&format!("\"{}\"", s.replace('\\', "\\\\").replace('"', "\\\"")));
            }
            Literal::Int(n) => {
                self.emit(&n.to_string());
            }
            Literal::Float(n) => {
                self.emit(&n.to_string());
            }
            Literal::Bool(b) => {
                self.emit(if *b { "true" } else { "false" });
            }
            Literal::Null => {
                self.emit("None");
            }
            Literal::Unit => {
                self.emit("()");
            }
        }
    }

    fn binary_op_to_rust(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "==",
            BinaryOp::NotEq => "!=",
            BinaryOp::Lt => "<",
            BinaryOp::Gt => ">",
            BinaryOp::LtEq => "<=",
            BinaryOp::GtEq => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
        }
    }

    fn compound_op_to_rust(&self, op: &CompoundAssignOp) -> &'static str {
        match op {
            CompoundAssignOp::AddAssign => "+",
            CompoundAssignOp::SubAssign => "-",
            CompoundAssignOp::MulAssign => "*",
            CompoundAssignOp::DivAssign => "/",
        }
    }

    /// Generate matches! macro for SWC
    fn gen_matches_macro(&mut self, scrutinee: &Expr, pattern: &Expr) {
        // For SWC, we generate a boolean expression with nested if-let patterns
        // For simplicity, we'll generate a simpler check that works for common cases
        self.emit("{\n");
        self.indent += 1;
        self.emit_indent();
        self.emit("let __matched = ");
        self.gen_swc_pattern_check(scrutinee, pattern, 0);
        self.emit(";\n");
        self.emit_indent();
        self.emit("__matched\n");
        self.indent -= 1;
        self.emit_indent();
        self.emit("}");
    }

    fn gen_swc_pattern_check(&mut self, scrutinee: &Expr, pattern: &Expr, depth: usize) {
        match pattern {
            Expr::StructInit(init) => {
                // Check if this is a wildcard pattern TypeName(_)
                if init.fields.len() == 1 && init.fields[0].0 == "_wildcard" {
                    // Wildcard pattern - just check the type
                    self.emit("matches!(");
                    self.gen_expr(scrutinee);
                    self.emit(", ");

                    // Use mapping module for SWC enum variants
                    if let Some(mapping) = get_node_mapping(&init.name) {
                        // Extract the enum variant pattern (e.g., "Expr::Call(_)")
                        let pattern_parts: Vec<&str> = mapping.swc_pattern.split('(').collect();
                        if let Some(variant) = pattern_parts.get(0) {
                            self.emit(&format!("{}(_)", variant));
                        } else {
                            self.emit(&format!("{}(_)", mapping.swc_pattern));
                        }
                    } else {
                        // Fallback for unknown types
                        self.emit(&format!("{}(_)", init.name));
                    }
                    self.emit(")");
                    return;
                }

                let swc_type = self.reluxscript_to_swc_type(&init.name.to_lowercase());

                // For nested patterns, we need to check the type and fields
                // Generate: matches!(scrutinee, SomeType { .. }) && field checks

                self.emit("matches!(");
                self.gen_expr(scrutinee);
                self.emit(", ");

                // Use mapping module for SWC enum variants
                if let Some(mapping) = get_node_mapping(&init.name) {
                    // Use the swc_pattern from mapping (e.g., "Expr::Ident(ident)")
                    // but we need just the pattern without binding
                    let pattern = mapping.swc_pattern.replace(|c: char| c.is_lowercase() || c == '_', "");
                    let pattern = if pattern.ends_with("()") {
                        pattern.replace("()", "(_)")
                    } else {
                        format!("{}(_)", mapping.swc_pattern.split('(').next().unwrap_or(&mapping.swc_pattern))
                    };
                    self.emit(&pattern);
                } else if init.name == "StringLiteral" {
                    self.emit("Expr::Lit(Lit::Str(_))");
                } else {
                    self.emit(&format!("{}{{ .. }}", swc_type));
                }
                self.emit(")");

                // Generate field checks with && chains
                for (field_name, field_pattern) in &init.fields {
                    self.emit(" && ");

                    // Generate field access - need to unwrap the enum first
                    let unwrap_prefix = if let Some(mapping) = get_node_mapping(&init.name) {
                        // Generate: if let Pattern = &expr { ... }
                        format!("if let {} = &", mapping.swc_pattern)
                    } else {
                        String::new()
                    };

                    if !unwrap_prefix.is_empty() {
                        self.emit("{ ");
                        self.emit(&unwrap_prefix);
                        self.gen_expr(scrutinee);
                        self.emit(" { ");
                    }

                    let field_var = format!("__f{}", depth);
                    match field_pattern {
                        Expr::Literal(Literal::String(s)) => {
                            // String equality check on field
                            // Use field mapping to get correct SWC field name
                            let swc_field = get_field_mapping(&init.name, field_name)
                                .map(|m| m.swc)
                                .unwrap_or(field_name.as_str());

                            // Get the variable name from the pattern binding
                            let var_name = get_node_mapping(&init.name)
                                .map(|m| {
                                    // Extract binding name from pattern like "Expr::Ident(ident)" -> "ident"
                                    m.swc_pattern
                                        .split('(')
                                        .nth(1)
                                        .and_then(|s| s.strip_suffix(')'))
                                        .unwrap_or("n")
                                })
                                .unwrap_or("n");

                            self.emit(&format!("&*{}.{} == \"{}\"", var_name, swc_field, s));
                        }
                        Expr::StructInit(nested) => {
                            // Nested pattern - recursive check
                            // Get the variable name from the pattern binding
                            let obj_var = get_node_mapping(&init.name)
                                .map(|m| {
                                    m.swc_pattern
                                        .split('(')
                                        .nth(1)
                                        .and_then(|s| s.strip_suffix(')'))
                                        .unwrap_or("n")
                                })
                                .unwrap_or("n");

                            // Use field mapping for the field name
                            let swc_field = get_field_mapping(&init.name, field_name)
                                .map(|m| m.swc)
                                .unwrap_or(field_name.as_str());

                            // Handle MemberProp specially - it's not an Expr
                            if init.name == "MemberExpression" && field_name == "property" {
                                // MemberProp needs special handling
                                if nested.name == "Identifier" {
                                    // MemberProp::Ident
                                    self.emit(&format!("matches!({}.prop, MemberProp::Ident(_))", obj_var));
                                    // Check name if specified
                                    for (nested_field, nested_val) in &nested.fields {
                                        if nested_field == "name" {
                                            if let Expr::Literal(Literal::String(s)) = nested_val {
                                                self.emit(&format!(" && {{ if let MemberProp::Ident(id) = &{}.prop {{ &*id.sym == \"{}\" }} else {{ false }} }}", obj_var, s));
                                            }
                                        }
                                    }
                                } else {
                                    self.emit("true /* unsupported MemberProp pattern */");
                                }
                            } else {
                                // Create a synthetic expression for the field access
                                let field_access = Expr::Ident(IdentExpr {
                                    name: format!("(*{}.{})", obj_var, swc_field),
                                    span: crate::lexer::Span::new(0, 0, 0, 0),
                                });
                                self.gen_swc_pattern_check(&field_access, &Expr::StructInit(nested.clone()), depth + 1);
                            }
                        }
                        _ => {
                            self.emit("true");
                        }
                    }

                    if !unwrap_prefix.is_empty() {
                        self.emit(" } else { false } }");
                    }
                }
            }
            Expr::Ident(ident) => {
                // Type check for a simple type name (e.g., MemberExpression)
                let type_name = &ident.name;

                // Use mapping to get the correct SWC pattern
                if let Some(mapping) = get_node_mapping(type_name) {
                    // Generate: matches!(scrutinee, Expr::Member(_))
                    self.emit("matches!(");
                    self.gen_expr(scrutinee);
                    self.emit(", ");

                    // Extract just the pattern part (e.g., "Expr::Member(_)")
                    let pattern_str = mapping.swc_pattern;
                    // Replace any binding variable with _
                    let pattern = if pattern_str.contains('(') {
                        let parts: Vec<&str> = pattern_str.split('(').collect();
                        format!("{}(_)", parts[0])
                    } else {
                        format!("{}{{ .. }}", pattern_str)
                    };
                    self.emit(&pattern);
                    self.emit(")");
                } else {
                    // Fallback: try common mappings
                    let swc_pattern = match type_name.as_str() {
                        "MemberExpression" => "Expr::Member(_)",
                        "CallExpression" => "Expr::Call(_)",
                        "Identifier" => "Expr::Ident(_)",
                        "FunctionDeclaration" => "Decl::Fn(_)",
                        "VariableDeclaration" => "Decl::Var(_)",
                        "ReturnStatement" => "Stmt::Return(_)",
                        "IfStatement" => "Stmt::If(_)",
                        "BlockStatement" => "Stmt::Block(_)",
                        _ => {
                            // Generate a placeholder
                            self.gen_expr(scrutinee);
                            self.emit(&format!(".is_{}()", type_name.to_lowercase()));
                            return;
                        }
                    };
                    self.emit(&format!("matches!("));
                    self.gen_expr(scrutinee);
                    self.emit(&format!(", {})", swc_pattern));
                }
            }
            _ => {
                // Literal or other pattern - generate equality check
                self.gen_expr(scrutinee);
                self.emit(" == ");
                self.gen_expr(pattern);
            }
        }
    }
}

impl Default for SwcGenerator {
    fn default() -> Self {
        Self::new()
    }
}
