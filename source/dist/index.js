// Generated by ReluxScript compiler
// Do not edit manually

module.exports = function({ types: t }) {
  const builder = {
    _output: [],
    _indentLevel: 0,
    append(s) { this._output.push(s); },
    newline() { this._output.push('\n'); },
    indent() { this._indentLevel++; },
    dedent() { this._indentLevel--; },
    toString() { return this._output.join(''); }
  };
  
  
  class State {
  constructor(component_name, use_state, use_effect, use_ref, event_handlers, render_jsx) {
      this.component_name = component_name;
      this.use_state = use_state;
      this.use_effect = use_effect;
      this.use_ref = use_ref;
      this.event_handlers = event_handlers;
      this.render_jsx = render_jsx;
    }
  }
  
  
  class UseStateInfo {
  constructor(name, setter, initial_value, csharp_type) {
      this.name = name;
      this.setter = setter;
      this.initial_value = initial_value;
      this.csharp_type = csharp_type;
    }
  }
  
  
  class UseEffectInfo {
  constructor(index, body, dependencies) {
      this.index = index;
      this.body = body;
      this.dependencies = dependencies;
    }
  }
  
  
  class UseRefInfo {
  constructor(name, initial_value) {
      this.name = name;
      this.initial_value = initial_value;
    }
  }
  
  
  class EventHandler {
  constructor(name, body) {
      this.name = name;
      this.body = body;
    }
  }
  
  
  class TranspilerOutput {
  constructor(csharp) {
      this.csharp = csharp;
    }
  }
  
  
  function process_function_body(body) {
    let effect_index = 0;
    for (const stmt of body.body) {
      if (stmt.type === "VariableDeclaration") {
        const var_decl = stmt;
        for (const declarator of var_decl.declarations) {
          const __iflet_0 = declarator.init;
          if (__iflet_0 !== null && __iflet_0 !== undefined) {
            const init = __iflet_0;
            if (init.type === "CallExpression") {
              const call = init;
              if (call.callee.type === "Identifier") {
                const callee = call.callee;
                if (callee.name === "useState") {
                  this.extract_use_state(declarator, call);
                } else if (callee.name === "useEffect") {
                  this.extract_use_effect(call, effect_index);
                  effect_index += 1;
                } else if (callee.name === "useRef") {
                  this.extract_use_ref(declarator, call);
                } else if (true) {
                }
              } else if (true) {
              }
            } else if (true) {
            }
          }
        }
      } else if (stmt.type === "ReturnStatement") {
        const ret = stmt;
        const __iflet_1 = ret.argument;
        if (__iflet_1 !== null && __iflet_1 !== undefined) {
          const arg = __iflet_1;
          if (arg.type === "JSXElement") {
            const jsx = arg;
            this.render_jsx = jsx;
          } else if (true) {
          }
        }
      } else if (stmt.type === "FunctionDeclaration") {
        const func = stmt;
        const __iflet_2 = func.id;
        if (__iflet_2 !== null && __iflet_2 !== undefined) {
          const id = __iflet_2;
          const handler_name = this.to_csharp_method_name(id.name);
          const body = this.function_body_to_csharp(func.body);
          this.event_handlers += { name: handler_name, body: body };
        }
      } else if (true) {
      }
    }
  }
  
  
  function extract_use_state(declarator, call) {
    if (declarator.id.type === "ArrayPattern") {
      const array_pattern = declarator.id;
      if ((array_pattern.elements.length >= 2)) {
        const state_name = this.get_pattern_name(array_pattern.elements[0]);
        const setter_name = this.get_pattern_name(array_pattern.elements[1]);
        const initial_value = ((call.arguments.length > 0) ? this.expr_to_csharp(call.arguments[0]) : "null".toString());
        const csharp_type = ((call.arguments.length > 0) ? this.infer_csharp_type(call.arguments[0]) : "dynamic".toString());
        this.use_state += { name: state_name, setter: setter_name, initial_value: initial_value, csharp_type: csharp_type };
      }
    } else if (true) {
    }
  }
  
  
  function extract_use_effect(call, index) {
    let body = "";
    let dependencies = [];
    if ((call.arguments.length > 0)) {
      if (call.arguments[0].type === "ArrowFunctionExpression") {
        const arrow = call.arguments[0];
        return body = this.function_body_to_csharp(arrow.body);
      } else if (true) {
      }
    }
    if ((call.arguments.length > 1)) {
      if (call.arguments[1].type === "ArrayExpression") {
        const arr = call.arguments[1];
        for (const elem of arr.elements) {
          const __iflet_3 = elem;
          if (__iflet_3 !== null && __iflet_3 !== undefined) {
            const expr = __iflet_3;
            if (expr.type === "Identifier") {
              const id = expr;
              dependencies += id.name;
            } else if (true) {
            }
          }
        }
      } else if (true) {
      }
    }
    return this.use_effect += { index: index, body: body, dependencies: dependencies };
  }
  
  
  function extract_use_ref(declarator, call) {
    if (declarator.id.type === "Identifier") {
      const id = declarator.id;
      const initial_value = ((call.arguments.length > 0) ? this.expr_to_csharp(call.arguments[0]) : "null".toString());
      return this.use_ref += { name: id.name, initial_value: initial_value };
    } else if (true) {
    }
  }
  
  
  function get_pattern_name(pattern) {
    const __iflet_4 = pattern;
    if (__iflet_4 !== null && __iflet_4 !== undefined) {
      const pat = __iflet_4;
      if (pat.type === "Identifier") {
        const id = pat;
        return id.name;
      } else if (true) {
        return "";
      }
    } else {
      "";
    }
  }
  
  
  function expr_to_csharp(expr) {
    if (expr.type === "NumericLiteral") {
      const num = expr;
      return num.value.toString();
    } else if (expr.type === "StringLiteral") {
      const s = expr;
      return `"${s.value}"`;
    } else if (expr.type === "BooleanLiteral") {
      const b = expr;
      return (b.value ? "true" : "false").toString();
    } else if (expr.type === "NullLiteral") {
      return "null".toString();
    } else if (expr.type === "Identifier") {
      const id = expr;
      return id.name;
    } else if (true) {
      return "null".toString();
    }
  }
  
  
  function infer_csharp_type(expr) {
    if (expr.type === "NumericLiteral") {
      const num = expr;
      if ((num.value === num.value.floor())) {
        "int".toString();
      } else {
        "double".toString();
      }
    } else if (expr.type === "StringLiteral") {
      return "string".toString();
    } else if (expr.type === "BooleanLiteral") {
      return "bool".toString();
    } else if (expr.type === "ArrayExpression") {
      return "List<dynamic>".toString();
    } else if (expr.type === "ObjectExpression") {
      return "Dictionary<string, dynamic>".toString();
    } else if (true) {
      return "dynamic".toString();
    }
  }
  
  
  function function_body_to_csharp(body) {
    let result = "";
    if (body.type === "BlockStatement") {
      const block = body;
      for (const stmt of block.body) {
        if (stmt.type === "ExpressionStatement") {
          const expr_stmt = stmt;
          if (expr_stmt.expression.type === "CallExpression") {
            const call = expr_stmt.expression;
            if (call.callee.type === "MemberExpression") {
              const member = call.callee;
              const is_log = this.is_console_log(member);
              if (is_log) {
                result += "        Console.WriteLine(";
                if ((call.arguments.length > 0)) {
                  result += this.template_literal_to_csharp(call.arguments[0]);
                }
                result += ");\n";
              }
            } else if (true) {
            }
          } else if (true) {
          }
        } else if (true) {
        }
      }
    } else if (true) {
    }
    return result;
  }
  
  
  function is_console_log(member) {
    if (member.object.type === "Identifier") {
      const obj = member.object;
      if (member.property.type === "Identifier") {
        const prop = member.property;
        return ((obj.name === "console") && (prop.name === "log"));
      } else if (true) {
        return false;
      }
    } else if (true) {
      return false;
    }
  }
  
  
  function template_literal_to_csharp(expr) {
    if (expr.type === "TemplateLiteral") {
      const tmpl = expr;
      let result = String.from("$\"");
      for (const [i, quasi] of tmpl.quasis.entries()) {
        result += quasi.value.cooked;
        if ((i < tmpl.expressions.length)) {
          result += "{";
          result += this.expr_to_csharp(tmpl.expressions[i]);
          result += "}";
        }
      }
      result += "\"";
      return result;
    } else if (true) {
      return this.expr_to_csharp(expr);
    }
  }
  
  
  function to_csharp_method_name(js_name) {
    let result = "";
    let capitalize_next = true;
    for (const ch of js_name) {
      if (capitalize_next) {
        result += ch.to_ascii_uppercase();
        capitalize_next = false;
      } else {
        result += ch;
      }
    }
    return result;
  }
  
  
  function jsx_to_vnode(jsx) {
    const tag = this.get_jsx_tag_name(jsx.opening_element.name);
    let attrs = [];
    for (const attr of jsx.opening_element.attributes) {
      if (attr.type === "JSXAttribute") {
        const attr_node = attr;
        const name = this.get_jsx_attr_name(attr_node.name);
        const value = (attr_node.value ? this.jsx_attr_value_to_csharp(val) : "\"true\"".toString());
        if (name.startsWith("on")) {
          attrs += `                ["${name}n"] = "${value.replace("\"", "")}"`;
        } else {
          if ((name === "ref")) {
            attrs += `                ["ref"] = "${value.replace("\"", "")}"`;
          } else {
            attrs += `                ["${name}"] = ${value}`;
          }
        }
      } else if (true) {
      }
    }
    let children = [];
    for (const child of jsx.children) {
      if (child.type === "JSXElement") {
        const elem = child;
        children += this.jsx_to_vnode(elem);
      } else if (child.type === "JSXText") {
        const text = child;
        const trimmed = text.value.trim();
        if (!(trimmed.length === 0)) {
          children += `"${trimmed}"`;
        }
      } else if (child.type === "JSXExpressionContainer") {
        const container = child;
        if (container.expression.type === "Expression") {
          const expr = container.expression;
          children += `\$"{${this.expr_to_csharp(expr)}}"`;
        } else if (true) {
        }
      } else if (true) {
      }
    }
    let result = `new VElement("${tag}", `;
    if (((attrs.length === 0) && (children.length === 0))) {
      result += "null, null)";
    } else {
      if ((attrs.length === 0)) {
        result += "null, ";
        if ((children.length === 1)) {
          result += children[0];
        } else {
          result += "new VNode[]\n            {\n                ";
          result += children.join(",\n                ");
          result += "\n            }";
        }
        result += ")";
      } else {
        result += "new Dictionary<string, string>\n            {\n";
        result += attrs.join(",\n");
        result += "\n            }, ";
        if ((children.length === 1)) {
          result += children[0];
        } else {
          if ((children.length > 1)) {
            result += "new VNode[]\n            {\n                ";
            result += children.join(",\n                ");
            result += "\n            }";
          } else {
            result += "null";
          }
        }
        result += ")";
      }
    }
    return result;
  }
  
  
  function get_jsx_tag_name(name) {
    if (name.type === "Identifier") {
      const id = name;
      return id.name;
    } else if (true) {
      return "div".toString();
    }
  }
  
  
  function get_jsx_attr_name(name) {
    if (name.type === "Identifier") {
      const id = name;
      return id.name;
    } else if (true) {
      return "unknown".toString();
    }
  }
  
  
  function jsx_attr_value_to_csharp(value) {
    if (value.type === "StringLiteral") {
      const s = value;
      return `"${s.value}"`;
    } else if (value.type === "JSXExpressionContainer") {
      const container = value;
      if (container.expression.type === "Expression") {
        const expr = container.expression;
        return this.expr_to_csharp(expr);
      } else if (true) {
        return "null".toString();
      }
    } else if (true) {
      return "null".toString();
    }
  }
  
  // Pre-hook
  
  function init() {
    return { component_name: "", use_state: [], use_effect: [], use_ref: [], event_handlers: [], render_jsx: null };
  }
  
  // Exit hook
  
  function finish() {
    let lines = [];
    lines += "using Minimact;".toString();
    lines += "using System;".toString();
    lines += "using System.Collections.Generic;".toString();
    lines += "using System.Linq;".toString();
    lines += "".toString();
    lines += "namespace Generated.Components".toString();
    lines += "{".toString();
    lines += "    [MinimactComponent]".toString();
    lines += `    public class ${this.component_name} : MinimactComponent`;
    lines += "    {".toString();
    for (const state of this.use_state) {
      lines += `        [UseState(${state.initial_value})]`;
      lines += `        private ${state.csharp_type} ${state.name};`;
      lines += "".toString();
    }
    for (const ref_info of this.use_ref) {
      lines += `        [UseRef(${ref_info.initial_value})]`;
      lines += `        private ElementRef ${ref_info.name};`;
      lines += "".toString();
    }
    for (const effect of this.use_effect) {
      const deps = ((effect.dependencies.length === 0) ? "" : `"${effect.dependencies.join("\", \"")}"`);
      lines += `        [UseEffect(${deps})]`;
      lines += `        private void Effect_${effect.index}()`;
      lines += "        {".toString();
      lines += effect.body;
      lines += "        }".toString();
      lines += "".toString();
    }
    lines += "        protected override VNode Render()".toString();
    lines += "        {".toString();
    const __iflet_5 = this.render_jsx;
    if (__iflet_5 !== null && __iflet_5 !== undefined) {
      const jsx = __iflet_5;
      lines += `            return ${this.jsx_to_vnode(jsx)};`;
    } else {
      lines += "            return VNull();".toString();
    }
    lines += "        }".toString();
    lines += "".toString();
    for (const handler of this.event_handlers) {
      lines += `        private void ${handler.name}()`;
      lines += "        {".toString();
      lines += handler.body;
      lines += "        }".toString();
    }
    lines += "    }".toString();
    lines += "}".toString();
    return { csharp: lines.join("\n") };
  }
  
  return {
    pre(file) {
      init(file);
    },
    
    visitor: {
      Program: {
        exit(path, state) {
          finish(path.node, state, builder);
        }
      },
      
      FunctionDeclaration(path) {
        const node = path.node;
        const __iflet_6 = node.id;
        if (__iflet_6 !== null && __iflet_6 !== undefined) {
          const id = __iflet_6;
          this.component_name = id.name;
        } else {
          return;
        }
        const __iflet_7 = node.body;
        if (__iflet_7 !== null && __iflet_7 !== undefined) {
          const body = __iflet_7;
          this.process_function_body(body);
        }
      },
    }
  };
};
