// Generated by ReluxScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP, SyntaxContext};
use swc_ecma_ast::*;
use swc_ecma_visit::{Visit, VisitMut, VisitMutWith, VisitWith};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use serde_json;
use std::fs;
use std::path::Path;


#[derive(Serialize)]
struct TranspilerOutput {
    csharp: String,
    templates: String,
    hooks: String,
}

#[derive(Clone, Serialize)]
struct ComponentInfo {
    name: String,
    props: Vec<PropInfo>,
    use_state: Vec<StateInfo>,
    use_effect: Vec<EffectInfo>,
    use_ref: Vec<RefInfo>,
    event_handlers: Vec<EventHandlerInfo>,
    render_body: Option<Box<Expr>>,
    templates: HashMap<String, Template>,
}

#[derive(Clone, Serialize)]
struct PropInfo {
    name: String,
    prop_type: String,
    optional: bool,
}

#[derive(Clone, Serialize)]
struct StateInfo {
    name: String,
    setter: Option<String>,
    initial_value: String,
    state_type: String,
}

#[derive(Clone, Serialize)]
struct EffectInfo {
    dependencies: Vec<String>,
    is_client_side: bool,
}

#[derive(Clone, Serialize)]
struct RefInfo {
    name: String,
    initial_value: String,
}

#[derive(Clone, Serialize)]
struct EventHandlerInfo {
    name: String,
    params: Vec<String>,
    is_async: bool,
}

#[derive(Clone, Serialize)]
struct Template {
    path: String,
    template: String,
    bindings: Vec<String>,
}

#[derive(Clone, Serialize)]
struct HookSignature {
    name: String,
    hook_type: String,
}

#[derive(Clone, Debug)]
struct __InlineVisitor_0 {
    component: &mut i32,
}

impl VisitMut for __InlineVisitor_0 {
    fn visit_mut_var_declarator(&mut self, decl: &mut VarDeclarator) {
        if let Some(init) = &decl.init {
            if matches!(init, CallExpression) {
                extract_hook_from_call(init, &decl.id, &mut component)
            }
        }
    }
    
    fn visit_mut_return_stmt(&mut self, ret: &mut ReturnStmt) {
        if let Some(arg) = &ret.argument {
            if matches!(arg, JSXElement) {
                component.render_body = Some(arg.clone())
            }
        }
    }
    
}

pub struct MinimactTranspiler {
    output: String,
    indent_level: usize,
    templates: HashMap<String, Template>,
    hooks: Vec<HookSignature>,
    current_component: Option<ComponentInfo>,
    components: Vec<ComponentInfo>,
}

impl Visit for MinimactTranspiler {}

impl MinimactTranspiler {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            templates: HashMap::new(),
            hooks: Vec::new(),
            current_component: None,
            components: Vec::new(),
        }
    }
    
    fn append(&mut self, s: &str) {
        self.output.push_str(s);
    }
    
    fn append_line(&mut self, s: &str) {
        for _ in 0..self.indent_level {
            self.output.push_str("    ");
        }
        self.output.push_str(s);
        self.output.push('\n');
    }
    
    fn indent(&mut self) {
        self.indent_level += 1;
    }
    
    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
    
    fn newline(&mut self) {
        self.output.push('\n');
    }
    
    pub fn to_string(&self) -> String {
        self.output.clone()
    }
    
    fn visit_mut_fn_decl(&mut self, node: &FnDecl) {
        let name = node.ident.sym.to_string();
        if !Self::is_pascal_case(&name) {
            return;
        }
        let mut component = ComponentInfo::new(name.clone());
        if (node.function.params.len() > 0) {
            Self::extract_props(&node.function.params[0], &mut component)
        }
        if let Some(body) = &node.body {
            body.visit_mut_with(&mut __InlineVisitor_0 { component: &mut component })
        }
        self.components.push(component);
    }
    
    // Exit-hook
    pub fn finish(&mut self) -> TranspilerOutput {
        let mut csharp_code = String::new();
        for component in &self.components {
            let code = Self::generate_csharp_class(&component);
            csharp_code.push_str(&code);
            csharp_code.push_str("\n")
        }
        let mut all_templates = HashMap::new();
        for component in &self.components {
            for (key, template) in &component.templates {
                let full_key = format!("{}.{}", component.name, key);
                all_templates.insert(full_key, template.clone())
            }
        }
        TranspilerOutput { csharp: csharp_code, templates: json::to_string_pretty(&all_templates).unwrap(), hooks: json::to_string_pretty(&self.hooks).unwrap() }
    }
    
    fn component_info_new(&mut self, name: String) -> ComponentInfo {
        ComponentInfo { name: name, props: vec![], use_state: vec![], use_effect: vec![], use_ref: vec![], event_handlers: vec![], render_body: None, templates: HashMap::new() }
    }
    
    fn is_pascal_case(&mut self, name: &String) -> bool {
        if (name.len() == 0) {
            return false;
        }
        let first_char = name.chars().next().unwrap();
        return first_char.is_uppercase();
    }
    
    fn extract_props(&mut self, param: &Pat, component: &mut ComponentInfo) {
        if match param {
            ObjectPattern => {
                true
            }
            _ => {
                false
            }
        } {
            for prop in &param.properties {
                if match prop {
                    ObjectPatternProperty => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    let prop_name = prop.key.name.to_string();
                    component.props.push(PropInfo { name: prop_name, prop_type: "dynamic".to_string(), optional: false })
                }
            }
        } else {
            if match param {
                Identifier => {
                    true
                }
                _ => {
                    false
                }
            } {
            }
        }
    }
    
    fn extract_hook_from_call(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match call.callee.as_expr().unwrap() {
            Identifier => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let callee_name = call.callee.as_expr().unwrap().name.to_string();
        if ((callee_name == "useState") || (callee_name == "useClientState")) {
            Self::extract_use_state(call, binding, component)
        } else {
            if (callee_name == "useEffect") {
                Self::extract_use_effect(call, component)
            } else {
                if (callee_name == "useRef") {
                    Self::extract_use_ref(call, binding, component)
                } else {
                    if callee_name.starts_with("use") {
                    }
                }
            }
        }
    }
    
    fn extract_use_state(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match binding {
            ArrayPattern => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let arr = binding.clone();
        if (arr.elements.len() < 1) {
            return;
        }
        let state_var = arr.elements[0].name.to_string();
        let setter_var = if (arr.elements.len() > 1) {
            Some(arr.elements[1].name.to_string())
        } else {
            None
        };
        let initial_value = if (call.args.len() > 0) {
            Self::expr_to_csharp(&call.args[0])
        } else {
            "null".to_string()
        };
        let state_type = if (call.args.len() > 0) {
            Self::infer_csharp_type(&call.args[0])
        } else {
            "dynamic".to_string()
        };
        component.use_state.push(StateInfo { name: state_var, setter: setter_var, initial_value: initial_value, state_type: state_type });
    }
    
    fn extract_use_effect(&mut self, call: &CallExpr, component: &mut ComponentInfo) {
        let mut deps = vec![];
        if (call.args.len() > 1) {
            let deps_arg = &call.args[1];
            if match deps_arg {
                ArrayExpression => {
                    true
                }
                _ => {
                    false
                }
            } {
                for elem in &deps_arg.elements {
                    if match elem {
                        Identifier => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        deps.push(elem.name.to_string())
                    }
                }
            }
        }
        component.use_effect.push(EffectInfo { dependencies: deps, is_client_side: false });
    }
    
    fn extract_use_ref(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match binding {
            Identifier => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let ref_name = binding.name.to_string();
        let initial_value = if (call.args.len() > 0) {
            Self::expr_to_csharp(&call.args[0])
        } else {
            "null".to_string()
        };
        component.use_ref.push(RefInfo { name: ref_name, initial_value: initial_value });
    }
    
    fn expr_to_csharp(&mut self, expr: &Expr) -> String {
        if match expr {
            StringLiteral => {
                true
            }
            _ => {
                false
            }
        } {
            return format!("\"{}\"", expr.value);
        } else {
            if match expr {
                NumericLiteral => {
                    true
                }
                _ => {
                    false
                }
            } {
                return expr.value.to_string();
            } else {
                if match expr {
                    BooleanLiteral => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    return if expr.value {
                        "true".to_string()
                    } else {
                        "false".to_string()
                    }.to_string();
                } else {
                    if match expr {
                        NullLiteral => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        return "null".to_string();
                    } else {
                        if match expr {
                            Identifier => {
                                true
                            }
                            _ => {
                                false
                            }
                        } {
                            return expr.name.to_string();
                        } else {
                            if match expr {
                                ArrayExpression => {
                                    true
                                }
                                _ => {
                                    false
                                }
                            } {
                                return "new List<dynamic>()".to_string();
                            } else {
                                if match expr {
                                    ObjectExpression => {
                                        true
                                    }
                                    _ => {
                                        false
                                    }
                                } {
                                    return "new Dictionary<string, dynamic>()".to_string();
                                }
                            }
                        }
                    }
                }
            }
        }
        return "null".to_string();
    }
    
    fn infer_csharp_type(&mut self, expr: &Expr) -> String {
        if match expr {
            StringLiteral => {
                true
            }
            _ => {
                false
            }
        } {
            return "string".to_string();
        } else {
            if match expr {
                NumericLiteral => {
                    true
                }
                _ => {
                    false
                }
            } {
                let val = expr.value;
                if (val == val.floor()) {
                    return "int".to_string();
                } else {
                    return "double".to_string();
                }
            } else {
                if match expr {
                    BooleanLiteral => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    return "bool".to_string();
                } else {
                    if match expr {
                        ArrayExpression => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        return "List<dynamic>".to_string();
                    } else {
                        if match expr {
                            ObjectExpression => {
                                true
                            }
                            _ => {
                                false
                            }
                        } {
                            return "Dictionary<string, dynamic>".to_string();
                        }
                    }
                }
            }
        }
        return "dynamic".to_string();
    }
    
    fn generate_csharp_class(&mut self, component: &ComponentInfo) -> String {
        let mut builder = String::new();
        { builder.push_str(&"using Minimact.Core;"); builder.push_str("\n"); };
        { builder.push_str(&"using Minimact.VDom;"); builder.push_str("\n"); };
        { builder.push_str(&"using System.Collections.Generic;"); builder.push_str("\n"); };
        builder.push_str("\n");
        { builder.push_str(&format!("public class {} : MinimactComponent", component.name)); builder.push_str("\n"); };
        { builder.push_str(&"{"); builder.push_str("\n"); };
        ();
        for state in &component.use_state {
            { builder.push_str(&format!("[State] private {} {} = {};", state.state_type, state.name, state.initial_value)); builder.push_str("\n"); }
        }
        for ref_info in &component.use_ref {
            { builder.push_str(&format!("[Ref] private object {} = {};", ref_info.name, ref_info.initial_value)); builder.push_str("\n"); }
        }
        if ((component.use_state.len() > 0) || (component.use_ref.len() > 0)) {
            builder.push_str("\n")
        }
        { builder.push_str(&"protected override VNode Render()"); builder.push_str("\n"); };
        { builder.push_str(&"{"); builder.push_str("\n"); };
        ();
        if component.render_body.is_some() {
            { builder.push_str(&"// TODO: Generate VNode from JSX"); builder.push_str("\n"); };
            { builder.push_str(&"return new VNull();"); builder.push_str("\n"); }
        } else {
            { builder.push_str(&"return new VNull();"); builder.push_str("\n"); }
        }
        ();
        { builder.push_str(&"}"); builder.push_str("\n"); };
        ();
        { builder.push_str(&"}"); builder.push_str("\n"); };
        return builder.clone();
    }
    
}
