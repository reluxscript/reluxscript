// Generated by ReluxScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP, SyntaxContext};
use swc_ecma_ast::*;
use swc_ecma_visit::{Visit, VisitMut, VisitMutWith, VisitWith};
use serde::{Serialize, Deserialize};
use serde_json;
use std::fs;
use std::path::Path;


#[derive(Serialize)]
struct TranspilerOutput {
    csharp: String,
    templates: String,
    hooks: String,
}

#[derive(Clone, Serialize)]
struct ComponentInfo {
    name: String,
    props: Vec<PropInfo>,
    use_state: Vec<StateInfo>,
    use_effect: Vec<EffectInfo>,
    use_ref: Vec<RefInfo>,
    event_handlers: Vec<EventHandlerInfo>,
    render_body: Option<Box<Expr>>,
    templates: HashMap<String, Template>,
}

#[derive(Clone, Serialize)]
struct PropInfo {
    name: String,
    prop_type: String,
    optional: bool,
}

#[derive(Clone, Serialize)]
struct StateInfo {
    name: String,
    setter: Option<String>,
    initial_value: String,
    state_type: String,
}

#[derive(Clone, Serialize)]
struct EffectInfo {
    dependencies: Vec<String>,
    is_client_side: bool,
}

#[derive(Clone, Serialize)]
struct RefInfo {
    name: String,
    initial_value: String,
}

#[derive(Clone, Serialize)]
struct EventHandlerInfo {
    name: String,
    params: Vec<String>,
    is_async: bool,
}

#[derive(Clone, Serialize)]
struct Template {
    path: String,
    template: String,
    bindings: Vec<String>,
}

#[derive(Clone, Serialize)]
struct HookSignature {
    name: String,
    hook_type: String,
}

pub struct MinimactTranspiler {
    output: String,
    indent_level: usize,
    templates: HashMap<String, Template>,
    hooks: Vec<HookSignature>,
    current_component: Option<ComponentInfo>,
    components: Vec<ComponentInfo>,
}

impl Visit for MinimactTranspiler {}

impl MinimactTranspiler {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
            templates: HashMap::new(),
            hooks: Vec::new(),
            current_component: None,
            components: Vec::new(),
        }
    }
    
    fn append(&mut self, s: &str) {
        self.output.push_str(s);
    }
    
    fn newline(&mut self) {
        self.output.push('\n');
    }
    
    pub fn to_string(&self) -> String {
        self.output.clone()
    }
    
    fn visit_mut_fn_decl(&mut self, node: &FnDecl) {
        let name = node.ident.sym.to_string();
        if !Self::is_pascal_case(&name) {
            return;
        }
        let mut component = ComponentInfo::new(name.clone());
        if (node.function.params.len() > 0) {
            Self::extract_props(&node.function.params[0], &mut component)
        }
        if let Some(body) = &node.body {
            // Traverse: TraverseStmt { target: Ident(IdentExpr { name: "body", span: Span { start: 1664, end: 1668, line: 59, column: 22 } }), captures: [Capture { name: "component", mutable: true, span: Span { start: 1681, end: 1682, line: 59, column: 39 } }], kind: Inline(InlineVisitor { state: [], methods: [FnDecl { is_pub: false, name: "visit_variable_declarator", type_params: [], params: [Param { name: "decl", ty: Reference { mutable: false, inner: Named("VariableDeclarator") }, span: Span { start: 1745, end: 1749, line: 60, column: 46 } }], return_type: None, where_clause: [], body: Block { stmts: [If(IfStmt { condition: Unary(UnaryExpr { op: Ref, operand: Member(MemberExpr { object: Ident(IdentExpr { name: "decl", span: Span { start: 1816, end: 1820, line: 61, column: 42 } }), property: "init", optional: false, computed: false, is_path: false, span: Span { start: 1826, end: 1827, line: 61, column: 52 } }), span: Span { start: 1815, end: 1816, line: 61, column: 41 } }), pattern: Some(Variant { name: "Some", inner: Some(Ident("init")) }), then_branch: Block { stmts: [If(IfStmt { condition: Matches(MatchesExpr { scrutinee: Ident(IdentExpr { name: "init", span: Span { start: 1865, end: 1869, line: 62, column: 37 } }), pattern: Ident("CallExpression"), span: Span { start: 1856, end: 1864, line: 62, column: 28 } }), pattern: None, then_branch: Block { stmts: [Expr(ExprStmt { expr: Call(CallExpr { callee: Ident(IdentExpr { name: "extract_hook_from_call", span: Span { start: 1918, end: 1940, line: 63, column: 29 } }), args: [Ident(IdentExpr { name: "init", span: Span { start: 1941, end: 1945, line: 63, column: 52 } }), Ref(RefExpr { mutable: false, expr: Member(MemberExpr { object: Ident(IdentExpr { name: "decl", span: Span { start: 1948, end: 1952, line: 63, column: 59 } }), property: "id", optional: false, computed: false, is_path: false, span: Span { start: 1955, end: 1956, line: 63, column: 66 } }), span: Span { start: 1947, end: 1948, line: 63, column: 58 } }), Ref(RefExpr { mutable: true, expr: Ident(IdentExpr { name: "component", span: Span { start: 1962, end: 1971, line: 63, column: 73 } }), span: Span { start: 1957, end: 1958, line: 63, column: 68 } })], type_args: [], optional: false, is_macro: false, span: Span { start: 1918, end: 1940, line: 63, column: 29 } }), span: Span { start: 1918, end: 1940, line: 63, column: 29 } })], span: Span { start: 1887, end: 1888, line: 62, column: 59 } }, else_if_branches: [], else_branch: None, span: Span { start: 1853, end: 1855, line: 62, column: 25 } })], span: Span { start: 1826, end: 1827, line: 61, column: 52 } }, else_if_branches: [], else_branch: None, span: Span { start: 1795, end: 1797, line: 61, column: 21 } })], span: Span { start: 1772, end: 1773, line: 60, column: 73 } }, span: Span { start: 1716, end: 1718, line: 60, column: 17 } }, FnDecl { is_pub: false, name: "visit_return_statement", type_params: [], params: [Param { name: "ret", ty: Reference { mutable: false, inner: Named("ReturnStatement") }, span: Span { start: 2088, end: 2091, line: 68, column: 43 } }], return_type: None, where_clause: [], body: Block { stmts: [If(IfStmt { condition: Unary(UnaryExpr { op: Ref, operand: Member(MemberExpr { object: Ident(IdentExpr { name: "ret", span: Span { start: 2154, end: 2157, line: 69, column: 41 } }), property: "argument", optional: false, computed: false, is_path: false, span: Span { start: 2167, end: 2168, line: 69, column: 54 } }), span: Span { start: 2153, end: 2154, line: 69, column: 40 } }), pattern: Some(Variant { name: "Some", inner: Some(Ident("arg")) }), then_branch: Block { stmts: [If(IfStmt { condition: Matches(MatchesExpr { scrutinee: Ident(IdentExpr { name: "arg", span: Span { start: 2206, end: 2209, line: 70, column: 37 } }), pattern: Ident("JSXElement"), span: Span { start: 2197, end: 2205, line: 70, column: 28 } }), pattern: None, then_branch: Block { stmts: [Expr(ExprStmt { expr: Assign(AssignExpr { target: Member(MemberExpr { object: Ident(IdentExpr { name: "component", span: Span { start: 2254, end: 2263, line: 71, column: 29 } }), property: "render_body", optional: false, computed: false, is_path: false, span: Span { start: 2276, end: 2277, line: 71, column: 51 } }), value: Call(CallExpr { callee: Ident(IdentExpr { name: "Some", span: Span { start: 2278, end: 2282, line: 71, column: 53 } }), args: [Call(CallExpr { callee: Member(MemberExpr { object: Ident(IdentExpr { name: "arg", span: Span { start: 2283, end: 2286, line: 71, column: 58 } }), property: "clone", optional: false, computed: false, is_path: false, span: Span { start: 2292, end: 2293, line: 71, column: 67 } }), args: [], type_args: [], optional: false, is_macro: false, span: Span { start: 2294, end: 2295, line: 71, column: 69 } })], type_args: [], optional: false, is_macro: false, span: Span { start: 2278, end: 2282, line: 71, column: 53 } }), span: Span { start: 2295, end: 2296, line: 71, column: 70 } }), span: Span { start: 2254, end: 2263, line: 71, column: 29 } })], span: Span { start: 2223, end: 2224, line: 70, column: 54 } }, else_if_branches: [], else_branch: None, span: Span { start: 2194, end: 2196, line: 70, column: 25 } })], span: Span { start: 2167, end: 2168, line: 69, column: 54 } }, else_if_branches: [], else_branch: None, span: Span { start: 2134, end: 2136, line: 69, column: 21 } })], span: Span { start: 2111, end: 2112, line: 68, column: 66 } }, span: Span { start: 2062, end: 2064, line: 68, column: 17 } }], span: Span { start: 1697, end: 1698, line: 59, column: 55 } }), span: Span { start: 1655, end: 1663, line: 59, column: 13 } }
        }
        self.components.push(component);
    }
    
    // Exit-hook
    pub fn finish(self: &Self) -> TranspilerOutput {
        let mut csharp_code = String::new();
        for component in &self.components {
            let code = Self::generate_csharp_class(&component);
            csharp_code.push_str(&code);
            csharp_code.push_str("\n")
        }
        let mut all_templates = HashMap::new();
        for component in &self.components {
            for (key, template) in &component.templates {
                let full_key = format!("{}.{}", component.name, key);
                all_templates.insert(full_key, template.clone())
            }
        }
        TranspilerOutput { csharp: csharp_code, templates: json::to_string_pretty(&all_templates).unwrap(), hooks: json::to_string_pretty(&self.hooks).unwrap() }
    }
    
    fn component_info_new(name: String) -> ComponentInfo {
        ComponentInfo { name: name, props: vec![], use_state: vec![], use_effect: vec![], use_ref: vec![], event_handlers: vec![], render_body: None, templates: HashMap::new() }
    }
    
    fn is_pascal_case(name: &String) -> bool {
        if (name.len() == 0) {
            return false;
        }
        let first_char = name.chars().next().unwrap();
        return first_char.is_uppercase();
    }
    
    fn extract_props(&mut self, param: &Pat, component: &mut ComponentInfo) {
        if match param {
            ObjectPattern => {
                true
            }
            _ => {
                false
            }
        } {
            for prop in &param.properties {
                if match prop {
                    ObjectPatternProperty => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    let prop_name = prop.key.name.to_string();
                    component.props.push(PropInfo { name: prop_name, prop_type: "dynamic".to_string(), optional: false })
                }
            }
        } else {
            if match param {
                Identifier => {
                    true
                }
                _ => {
                    false
                }
            } {
            }
        }
    }
    
    fn extract_hook_from_call(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match call.callee.as_expr().unwrap() {
            Identifier => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let callee_name = call.callee.as_expr().unwrap().name.to_string();
        if ((callee_name == "useState") || (callee_name == "useClientState")) {
            Self::extract_use_state(call, binding, component)
        } else {
            if (callee_name == "useEffect") {
                Self::extract_use_effect(call, component)
            } else {
                if (callee_name == "useRef") {
                    Self::extract_use_ref(call, binding, component)
                } else {
                    if callee_name.starts_with("use") {
                    }
                }
            }
        }
    }
    
    fn extract_use_state(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match binding {
            ArrayPattern => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let arr = binding.clone();
        if (arr.elements.len() < 1) {
            return;
        }
        let state_var = arr.elements[0].name.to_string();
        let setter_var = if (arr.elements.len() > 1) {
            Some(arr.elements[1].name.to_string())
        } else {
            None
        };
        let initial_value = if (call.args.len() > 0) {
            Self::expr_to_csharp(&call.args[0])
        } else {
            "null".to_string()
        };
        let state_type = if (call.args.len() > 0) {
            Self::infer_csharp_type(&call.args[0])
        } else {
            "dynamic".to_string()
        };
        component.use_state.push(StateInfo { name: state_var, setter: setter_var, initial_value: initial_value, state_type: state_type });
    }
    
    fn extract_use_effect(&mut self, call: &CallExpr, component: &mut ComponentInfo) {
        let mut deps = vec![];
        if (call.args.len() > 1) {
            let deps_arg = &call.args[1];
            if match deps_arg {
                ArrayExpression => {
                    true
                }
                _ => {
                    false
                }
            } {
                for elem in &deps_arg.elements {
                    if match elem {
                        Identifier => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        deps.push(elem.name.to_string())
                    }
                }
            }
        }
        component.use_effect.push(EffectInfo { dependencies: deps, is_client_side: false });
    }
    
    fn extract_use_ref(&mut self, call: &CallExpr, binding: &Pat, component: &mut ComponentInfo) {
        if !match binding {
            Identifier => {
                true
            }
            _ => {
                false
            }
        } {
            return;
        }
        let ref_name = binding.name.to_string();
        let initial_value = if (call.args.len() > 0) {
            Self::expr_to_csharp(&call.args[0])
        } else {
            "null".to_string()
        };
        component.use_ref.push(RefInfo { name: ref_name, initial_value: initial_value });
    }
    
    fn expr_to_csharp(expr: &Expr) -> String {
        if match expr {
            StringLiteral => {
                true
            }
            _ => {
                false
            }
        } {
            return format!("\"{}\"", expr.value);
        } else {
            if match expr {
                NumericLiteral => {
                    true
                }
                _ => {
                    false
                }
            } {
                return expr.value.to_string();
            } else {
                if match expr {
                    BooleanLiteral => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    return if expr.value {
                        "true".to_string()
                    } else {
                        "false".to_string()
                    }.to_string();
                } else {
                    if match expr {
                        NullLiteral => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        return "null".to_string();
                    } else {
                        if match expr {
                            Identifier => {
                                true
                            }
                            _ => {
                                false
                            }
                        } {
                            return expr.name.to_string();
                        } else {
                            if match expr {
                                ArrayExpression => {
                                    true
                                }
                                _ => {
                                    false
                                }
                            } {
                                return "new List<dynamic>()".to_string();
                            } else {
                                if match expr {
                                    ObjectExpression => {
                                        true
                                    }
                                    _ => {
                                        false
                                    }
                                } {
                                    return "new Dictionary<string, dynamic>()".to_string();
                                }
                            }
                        }
                    }
                }
            }
        }
        return "null".to_string();
    }
    
    fn infer_csharp_type(expr: &Expr) -> String {
        if match expr {
            StringLiteral => {
                true
            }
            _ => {
                false
            }
        } {
            return "string".to_string();
        } else {
            if match expr {
                NumericLiteral => {
                    true
                }
                _ => {
                    false
                }
            } {
                let val = expr.value;
                if (val == val.floor()) {
                    return "int".to_string();
                } else {
                    return "double".to_string();
                }
            } else {
                if match expr {
                    BooleanLiteral => {
                        true
                    }
                    _ => {
                        false
                    }
                } {
                    return "bool".to_string();
                } else {
                    if match expr {
                        ArrayExpression => {
                            true
                        }
                        _ => {
                            false
                        }
                    } {
                        return "List<dynamic>".to_string();
                    } else {
                        if match expr {
                            ObjectExpression => {
                                true
                            }
                            _ => {
                                false
                            }
                        } {
                            return "Dictionary<string, dynamic>".to_string();
                        }
                    }
                }
            }
        }
        return "dynamic".to_string();
    }
    
    fn generate_csharp_class(component: &ComponentInfo) -> String {
        let mut builder = String::new();
        builder.append_line(&"using Minimact.Core;");
        builder.append_line(&"using Minimact.VDom;");
        builder.append_line(&"using System.Collections.Generic;");
        builder.newline();
        builder.append_line(&format!("public class {} : MinimactComponent", component.name));
        builder.append_line(&"{");
        builder.indent();
        for state in &component.use_state {
            builder.append_line(&format!("[State] private {} {} = {};", state.state_type, state.name, state.initial_value))
        }
        for ref_info in &component.use_ref {
            builder.append_line(&format!("[Ref] private object {} = {};", ref_info.name, ref_info.initial_value))
        }
        if ((component.use_state.len() > 0) || (component.use_ref.len() > 0)) {
            builder.newline()
        }
        builder.append_line(&"protected override VNode Render()");
        builder.append_line(&"{");
        builder.indent();
        if component.render_body.is_some() {
            builder.append_line(&"// TODO: Generate VNode from JSX");
            builder.append_line(&"return new VNull();")
        } else {
            builder.append_line(&"return new VNull();")
        }
        builder.dedent();
        builder.append_line(&"}");
        builder.dedent();
        builder.append_line(&"}");
        return builder.to_string();
    }
    
}
