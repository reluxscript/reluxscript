// Generated by ReluxScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP};
use swc_ecma_ast::*;
use swc_ecma_visit::{VisitMut, VisitMutWith};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use serde_json;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Template {
    pub path: String,
    pub template: String,
    pub bindings: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub name: String,
    pub version: String,
    pub features: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Component {
    pub name: String,
    pub templates: HashMap<String, Template>,
    pub props: Vec<Prop>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Prop {
    pub name: String,
    pub prop_type: String,
    pub optional: bool,
}

pub struct JsonSerializationTest {
    // Plugin state
}

impl JsonSerializationTest {
    pub fn new() -> Self {
        Self {}
    }
    
    pub fn test_serialize_basic() -> String {
        let template = Template { path: "0.1.2", template: "${count}", bindings: vec!["count"] };
        let json_str = serde_json::to_string(&template);
        return json_str;
    }
    
    pub fn test_serialize_pretty() -> String {
        let config = Config { name: "my-plugin", version: "1.0.0", features: vec!["hooks", "jsx", "typescript"] };
        let json_str = serde_json::to_string_pretty(&config);
        return json_str;
    }
    
    pub fn test_manual_object() -> String {
        let mut obj = serde_json::obj();
        obj.insert("name", serde_json::string("MyComponent"));
        obj.insert("version", serde_json::number(1));
        obj.insert("enabled", serde_json::boolean(true));
        return serde_json::stringify(&obj);
    }
    
    pub fn test_manual_array() -> String {
        let mut arr = serde_json::array();
        arr.push(serde_json::string("item1"));
        arr.push(serde_json::string("item2"));
        arr.push(serde_json::number(42));
        return serde_json::stringify(&arr);
    }
    
    pub fn save_config(config: &Config, path: &String) {
        let json_str = serde_json::to_string_pretty(config);
        fs::write(path, &json_str);
    }
}

impl VisitMut for JsonSerializationTest {
    
    fn visit_mut_program(&mut self, n: &mut Program) {
        let mut names = vec![];
        for item in &n.body {
            if let Decl::Fn(item) = &item {
                names.push(item.ident.sym.clone());
            }
        }
        let json_str = serde_json::to_string_pretty(&names);
        let path = "output/names.json";
        fs::write(&path, &json_str);
    }
}
