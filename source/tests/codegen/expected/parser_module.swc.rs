// Generated by ReluxScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP};
use swc_ecma_ast::*;
use swc_ecma_visit::{VisitMut, VisitMutWith};
use swc_common::{FileName, SourceMap};
use swc_ecma_parser::{Parser, StringInput, Syntax, TsConfig, EsConfig};
use std::sync::Arc;

pub struct ParserTest {
    // Plugin state
}

impl ParserTest {
    pub fn new() -> Self {
        Self {}
    }

    fn analyze_file(file_path: &String) -> Result<(), String> {
        let ast = parser::parse_file(file_path)?;
        Ok(());
    }

    fn parse_code_snippet(code: &String) -> Result<(), String> {
        let ast = parser::parse(code)?;
        Ok(());
    }

    fn parse_with_custom_syntax(code: &String) -> Result<(), String> {
        let ast = parser::parse_with_syntax(code, "TypeScript")?;
        Ok(());
    }
}

impl VisitMut for ParserTest {
}

// Parser module helper functions
mod parser {
    use super::*;

    pub fn parse_file(path: &str) -> Result<Program, String> {
        let source_map = Arc::new(SourceMap::default());
        let code = std::fs::read_to_string(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;
        let file = source_map.new_source_file(
            FileName::Real(path.into()),
            code,
        );
        let syntax = Syntax::Typescript(TsConfig {
            tsx: true,
            decorators: false,
            ..Default::default()
        });
        let mut parser = Parser::new(syntax, StringInput::from(&*file), None);
        parser.parse_program()
            .map_err(|e| format!("Parse error: {:?}", e))
    }

    pub fn parse(code: &str) -> Result<Program, String> {
        let source_map = Arc::new(SourceMap::default());
        let file = source_map.new_source_file(
            FileName::Anon,
            code.to_string(),
        );
        let syntax = Syntax::Typescript(TsConfig {
            tsx: true,
            decorators: false,
            ..Default::default()
        });
        let mut parser = Parser::new(syntax, StringInput::from(&*file), None);
        parser.parse_program()
            .map_err(|e| format!("Parse error: {:?}", e))
    }

    pub fn parse_with_syntax(code: &str, syntax_type: &str) -> Result<Program, String> {
        let source_map = Arc::new(SourceMap::default());
        let file = source_map.new_source_file(
            FileName::Anon,
            code.to_string(),
        );
        let syntax = match syntax_type {
            "TypeScript" => Syntax::Typescript(TsConfig {
                tsx: true,
                decorators: false,
                ..Default::default()
            }),
            "JSX" => Syntax::Es(EsConfig {
                jsx: true,
                ..Default::default()
            }),
            _ => Syntax::Es(EsConfig::default()),
        };
        let mut parser = Parser::new(syntax, StringInput::from(&*file), None);
        parser.parse_program()
            .map_err(|e| format!("Parse error: {:?}", e))
    }
}
