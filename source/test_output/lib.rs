// Generated by ReluxScript compiler
// Do not edit manually

use swc_common::{Span, DUMMY_SP, SyntaxContext};
use swc_ecma_ast::*;
use swc_ecma_visit::{VisitMut, VisitMutWith};
use std::collections::HashSet;

#[derive(Debug, Clone)]
pub struct HookInfo {
    pub name: String,
    pub hook_type: String,
    pub args_count: i32,
}

#[derive(Debug, Clone)]
pub struct ComponentStats {
    pub name: String,
    pub hooks: Vec<HookInfo>,
    pub has_jsx: bool,
}

#[derive(Debug, Clone)]
pub struct MemberInfo {
    pub object: String,
    pub property: String,
}

#[derive(Debug, Clone)]
pub struct State {
    pub components: Vec<ComponentStats>,
    pub current_component: Option<String>,
    pub removed_count: i32,
    pub visited_nodes: HashSet<String>,
}

pub struct KitchenSinkPlugin {
    // Plugin state
}

impl KitchenSinkPlugin {
    pub fn new() -> Self {
        Self {}
    }
    
    fn is_component_name(name: &String) -> bool {
        if name.is_empty() {
            return false;
        }
        let first_char = name.chars().next().unwrap();
        first_char.is_uppercase()
    }
    
    fn is_hook_call(name: &String) -> bool {
        (name.starts_with("use") && (name.len() > 3))
    }
    
    fn categorize_hook(name: &String) -> String {
        if ((name == "useState") || (name == "useReducer")) {
            return "state".into();
        }
        if ((name == "useEffect") || (name == "useLayoutEffect")) {
            return "effect".into();
        }
        if (name == "useRef") {
            return "ref".into();
        }
        if ((name == "useMemo") || (name == "useCallback")) {
            return "memo".into();
        }
        return format!("custom:{}", name);
    }
    
    fn should_remove_console(method: &String) -> bool {
        (((method == "log") || (method == "warn")) || (method == "debug"))
    }
    
    fn format_stats(stats: &ComponentStats) -> String {
        format!("{} has {} hooks", stats.name, stats.hooks.len())
    }
    
    fn get_callee_name(callee: &Expr) -> Option<String> {
        if let Expression::Identifier(id) = callee {
            Some(id.sym.clone())
        } else {
            if let Expression::MemberExpression(member) = callee {
                Some(member.prop.clone())
            } else {
                None
            }
        }
    }
    
    fn extract_member_call(call: &CallExpr) -> Option<MemberInfo> {
        if let Expression::MemberExpression(member) = &call.callee {
            if let Expression::Identifier(obj) = &member.obj {
                return Some(MemberInfo { object: obj.name.clone(), property: member.prop.clone() });
            }
        }
        None
    }
    
    fn collect_hook_names(component: &ComponentStats) -> Vec<String> {
        component.hooks.iter().map(|h| h.name.clone()).collect()
    }
    
    fn has_hooks(component: &ComponentStats) -> bool {
        (component.hooks.len() > 0)
    }
    
    fn count_by_type(component: &ComponentStats, target: &String) -> i32 {
        let mut count = 0;
        for hook in &component.hooks {
            if (hook.hook_type == *target) {
                count += 1
            }
        }
        count
    }
    
    fn get_first_hook(stats: &ComponentStats) -> Option<String> {
        if stats.hooks.is_empty() {
            None
        } else {
            Some(stats.hooks[0].name.clone())
        }
    }
    
    fn safe_get_name(stats: &ComponentStats) -> Result<String, String> {
        if stats.name.is_empty() {
            Err("No name")
        } else {
            Ok(stats.name.clone())
        }
    }
    
    fn process_component(stats: &ComponentStats) -> Result<(), String> {
        let _name = safe_get_name(stats)?;
        let _first_hook = get_first_hook(stats).unwrap_or("none".into());
        Ok(())
    }
}

impl VisitMut for KitchenSinkPlugin {
    
    fn visit_mut_fn_decl(&mut self, n: &mut FnDecl) {
        let name = n.ident.sym.clone();
        if is_component_name(&name) {
            self.state.current_component = Some(name.clone());
            let stats = ComponentStats { name: name.clone(), hooks: vec![], has_jsx: false };
            self.state.components.push(stats);
        }
        n.visit_mut_children_with(self);
        self.state.current_component = None;
    }
    
    fn visit_mut_call_expr(&mut self, n: &mut CallExpr) {
        if let Some(component_name) = &self.state.current_component {
            if let Some(callee_name) = get_callee_name(&n.callee) {
                if is_hook_call(&callee_name) {
                    let hook_info = HookInfo { name: callee_name.clone(), hook_type: categorize_hook(&callee_name), args_count: 0 };
                    for component in &mut self.state.components {
                        if (component.name == *component_name) {
                            component.hooks.push(hook_info);
                            break;
                        }
                    }
                }
            }
        }
        if let Some(member) = extract_member_call(n) {
            if ((member.object == "console") && should_remove_console(&member.property)) {
                self.state.removed_count += 1
            }
        }
        n.visit_mut_children_with(self)
    }
    
    fn visit_mut_ident(&mut self, n: &mut Ident) {
        let name = n.sym.clone();
        self.state.visited_nodes.insert(name.clone());
        if (name == "oldName") {
            *n = Ident::new("newName".into(), DUMMY_SP, SyntaxContext::empty());
        }
        if matches!(n.sym.as_str(), "foo" | "bar" | "baz") {
            let new_name = format!("renamed_{}", n.sym);
            *n = Ident::new(new_name.into(), DUMMY_SP, SyntaxContext::empty());
        }
    }
    
    fn visit_mut_jsx_element(&mut self, n: &mut JSXElement) {
        if let Some(component_name) = &self.state.current_component {
            for component in &mut self.state.components {
                if (component.name == *component_name) {
                    let updated = ComponentStats { name: component.name.clone(), hooks: component.hooks.clone(), has_jsx: true };
                    *component = updated;
                    break;
                }
            }
        }
        n.visit_mut_children_with(self)
    }
    
    fn visit_mut_variable_declarator(&mut self, n: &mut VariableDeclarator) {
        if let Some(init) = &n.init {
            if let Expression::ArrayExpression(arr) = init {
                let _size = arr.elements.len();
            }
        }
        n.visit_mut_children_with(self)
    }
}
