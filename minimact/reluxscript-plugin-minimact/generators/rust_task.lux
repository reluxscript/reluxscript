/**
 * Rust Task Generator
 *
 * Generates Rust async task code from useServerTask calls with runtime: 'rust'
 */

use fs;
use path;
use "../transpilers/typescript_to_rust.lux" { transpile_async_function_to_rust };
use "../types/component_types.lux" { Component, ServerTask };

pub struct GeneratedTaskFile {
    pub task_id: Str,
    pub file_name: Str,
    pub file_path: Str,
    pub parallel: bool
}

/**
 * Generate Rust task files for all Rust-based server tasks
 */
pub fn generate_rust_task_files(
    component: &Component,
    output_dir: &Str
) -> Result<Vec<GeneratedTaskFile>, Str> {
    if let Some(use_server_task) = &component.use_server_task {
        if use_server_task.is_empty() {
            return Ok(vec![]);
        }

        let rust_tasks: Vec<&ServerTask> = use_server_task.iter()
            .filter(|task| task.runtime == "rust")
            .collect();

        if rust_tasks.is_empty() {
            return Ok(vec![]);
        }

        let mut generated_files = vec![];

        for (i, task) in rust_tasks.iter().enumerate() {
            let task_id = format!("server_task_{}", i);
            let file_name = format!("{}.rs", task_id);
            let file_path = path::join(vec![output_dir.clone(), file_name.clone()]);

            // Generate Rust code
            let rust_code = generate_rust_task(task, &task_id, i)?;

            // Write file
            fs::create_dir_all(output_dir)?;
            fs::write_file(&file_path, rust_code)?;

            generated_files.push(GeneratedTaskFile {
                task_id: task_id.clone(),
                file_name: file_name.clone(),
                file_path,
                parallel: task.parallel
            });

            println!("[Rust] Generated {} ({})",
                file_name,
                if task.parallel { "parallel" } else { "sequential" }
            );
        }

        Ok(generated_files)
    } else {
        Ok(vec![])
    }
}

/**
 * Generate Rust task code
 */
fn generate_rust_task(
    task: &ServerTask,
    task_id: &Str,
    index: usize
) -> Result<Str, Str> {
    let function_name = "execute";
    let async_function = &task.async_function;
    let params = &task.parameters;
    let return_type = task.return_type.as_ref()
        .map(|s| s.as_str())
        .unwrap_or("serde_json::Value");
    let parallel = task.parallel;

    // Start building Rust code
    let mut code = vec![];

    // File header
    code.push("//! Auto-generated Rust task from TypeScript useServerTask".to_string());
    code.push("//! Generated by Minimact Babel Plugin".to_string());
    code.push("".to_string());
    code.push("use serde::{Deserialize, Serialize};".to_string());
    code.push("use serde_json::Value;".to_string());
    code.push("use tokio::sync::mpsc;".to_string());

    if parallel {
        code.push("use rayon::prelude::*;".to_string());
    }

    code.push("".to_string());

    // Input struct
    code.push("/// Task input parameters".to_string());
    code.push("#[derive(Debug, Clone, Serialize, Deserialize)]".to_string());
    code.push("pub struct TaskInput {".to_string());

    if params.len() > 0 {
        for param in params {
            let rust_type = convert_type_to_rust(&param.param_type);
            code.push(format!("    pub {}: {},", param.name, rust_type));
        }
    } else {
        code.push("    // No input parameters".to_string());
    }

    code.push("}".to_string());
    code.push("".to_string());

    // Output struct
    code.push("/// Task output result".to_string());
    code.push("#[derive(Debug, Clone, Serialize, Deserialize)]".to_string());
    code.push("pub struct TaskOutput {".to_string());
    code.push(format!("    pub result: {},", convert_type_to_rust(return_type)));
    code.push("}".to_string());
    code.push("".to_string());

    // Task function
    let param_names = params.iter()
        .map(|p| p.name.clone())
        .collect::<Vec<_>>()
        .join(", ");

    let parallel_str = if parallel { ", parallel: true" } else { "" };

    code.push("/// Execute task".to_string());
    code.push(format!("/// Original TypeScript: useServerTask(async ({}) => {{ ... }}, {{ runtime: 'rust'{} }})", param_names, parallel_str));
    code.push("pub async fn execute(".to_string());
    code.push("    input: TaskInput,".to_string());
    code.push("    progress_tx: Option<mpsc::Sender<f64>>,".to_string());
    code.push(") -> Result<TaskOutput, Box<dyn std::error::Error + Send + Sync>> {".to_string());

    // Transpile function body
    let rust_body = transpile_async_function_to_rust(async_function)?;

    code.push(rust_body);

    code.push("}".to_string());
    code.push("".to_string());

    Ok(code.join("\n"))
}

/**
 * Convert TypeScript type to Rust type
 */
pub fn convert_type_to_rust(ts_type: &Str) -> Str {
    // Handle array types: number[] → Vec<f64>
    if ts_type.ends_with("[]") {
        let element_type = &ts_type[..ts_type.len() - 2];
        let rust_element_type = convert_type_to_rust(&element_type.to_string());
        return format!("Vec<{}>", rust_element_type);
    }

    // Handle List<T> types
    if ts_type.starts_with("List<") && ts_type.ends_with(">") {
        let inner_type = &ts_type[5..ts_type.len() - 1];
        let rust_inner_type = convert_type_to_rust(&inner_type.to_string());
        return format!("Vec<{}>", rust_inner_type);
    }

    // Handle Promise<T> → T (async fn already returns Future)
    if ts_type.starts_with("Promise<") && ts_type.ends_with(">") {
        let inner_type = &ts_type[8..ts_type.len() - 1];
        return convert_type_to_rust(&inner_type.to_string());
    }

    // Type mappings
    match ts_type.as_str() {
        "string" => "String".into(),
        "number" => "f64".into(),
        "double" => "f64".into(),
        "boolean" => "bool".into(),
        "bool" => "bool".into(),
        "object" => "serde_json::Value".into(),
        "any" => "serde_json::Value".into(),
        "void" => "()".into(),
        "null" => "Option<serde_json::Value>".into(),
        "undefined" => "Option<serde_json::Value>".into(),
        _ => "serde_json::Value".into()
    }
}

/**
 * Generate Cargo.toml for Rust tasks
 */
pub fn generate_cargo_toml(
    output_dir: &Str,
    task_files: &Vec<GeneratedTaskFile>
) -> Result<(), Str> {
    let cargo_toml = r#"[package]
name = "minimact-rust-tasks"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
rayon = "1.7"

[[example]]
name = "test_task"
path = "examples/test.rs"
"#;

    let file_path = path::join(vec![output_dir.clone(), "Cargo.toml".into()]);
    fs::write_file(&file_path, cargo_toml.to_string())?;
    println!("[Rust] Generated Cargo.toml");

    Ok(())
}

/**
 * Generate lib.rs that exports all tasks
 */
pub fn generate_lib_rs(
    output_dir: &Str,
    task_files: &Vec<GeneratedTaskFile>
) -> Result<(), Str> {
    let mut code = vec![];

    code.push("//! Minimact Rust Tasks Library".to_string());
    code.push("//! Auto-generated from TypeScript useServerTask calls".to_string());
    code.push("".to_string());

    // Module declarations
    for task in task_files {
        code.push(format!("pub mod {};", task.task_id));
    }

    code.push("".to_string());
    code.push("// Re-exports".to_string());
    for task in task_files {
        let capitalized = capitalize(&task.task_id);
        code.push(format!(
            "pub use {}::{{TaskInput as {}Input, TaskOutput as {}Output, execute as execute_{}}};",
            task.task_id, capitalized, capitalized, task.task_id
        ));
    }

    let file_path = path::join(vec![output_dir.clone(), "lib.rs".into()]);
    fs::write_file(&file_path, code.join("\n"))?;
    println!("[Rust] Generated lib.rs");

    Ok(())
}

fn capitalize(s: &Str) -> Str {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => {
                    let mut result = first.to_uppercase().to_string();
                    result.push_str(&chars.collect::<String>());
                    result
                }
            }
        })
        .collect::<Vec<_>>()
        .join("")
}
